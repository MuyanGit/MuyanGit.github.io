<!DOCTYPE HTML>
<html class="no-js" lang="zh-CN">

<head>
    <!--[if lte IE 9]>
<meta http-equiv="refresh" content="0;url=https://muyangit.github.io/warn.html">
<![endif]-->
<!-- <script language=javascript> 
 if (document.domain =='coding.hojun.cn')  
     this.location = "https://www.hojun.cn" + this.location.pathname + this.location.search; 
</script> -->
<script>
  (function(d) {
    var config = {
      kitId: 'lsb6vmc',
      scriptTimeout: 3000000,
      async: true
    },
    h=d.documentElement,t=setTimeout(function(){h.className=h.className.replace(/\bwf-loading\b/g,"")+" wf-inactive";},config.scriptTimeout),tk=d.createElement("script"),f=false,s=d.getElementsByTagName("script")[0],a;h.className+=" wf-loading";tk.src='https://use.typekit.net/'+config.kitId+'.js';tk.async=true;tk.onload=tk.onreadystatechange=function(){a=this.readyState;if(f||a&&a!="complete"&&a!="loaded")return;f=true;clearTimeout(t);try{Typekit.load(config)}catch(e){}};s.parentNode.insertBefore(tk,s)
  })(document);
</script>
<meta charset="utf-8">

<link rel="canonical" href="https://www.hojun.com/2022/06/08/cl4s605cf001sawbhdef2fhpz/"/>
<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no">
<meta http-equiv="mobile-agent" content="format=html5; url=https://muyangit.github.io">
<meta name="author" content="MuyanGit">

<link rel="stylesheet" href="/css/SimpleStyle.css">

<!-- 
<link rel="stylesheet" href="/css/loading.css">
 -->

<link rel="stylesheet" href="/css/xiaomai.css">


<link rel="stylesheet" href="/css/share.min.css">


<link rel="stylesheet" href="/css/zoom.css">


<link rel="stylesheet" href="/css/jquery.fancybox.min.css">


<link rel="stylesheet" href="/css/iconfont/iconfont.css">


<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/MuyanGit/ImageHosting/images/favicon.ico">


<title>windows桌面程序自动化控制之uiautomation模块全面讲解 - MuyanGit</title>

<meta name="keywords" content="">

<meta name="description " content="尽小者大，慎微者著">
<meta name="baidu-site-verification" content="0hxFvBRyRY" />

    
    <!-- 自动广告 -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-5634033670687375",
            enable_page_level_ads: true
        });
    </script>


    <script type="application/ld+json">
    {
        "@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
        "@id": "https://www.hojun.com/2022/06/08/cl4s605cf001sawbhdef2fhpz/",
        "appid": "1594654793276567",
        "title": "Windows桌面程序自动化控制之uiautomation模块全面讲解",
        "pubDate": "2022-06-08T03:09:36"
    }
    </script>
    <script src="//msite.baidu.com/sdk/c.js?appid=1594654793276567"></script>
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
<div id="loading">
	<div id="loading-center">
		<div id="loading-center-absolute">
			<div class="object" id="object_five"></div>
			<div class="object" id="object_four"></div>
			<div class="object" id="object_three"></div>
			<div class="object" id="object_two"></div>
			<div class="object" id="object_one"></div>
		</div>
	</div>
</div>
<div id="nav">
    <nav class="nav-menu">
        <a class="site-name current" href="/" title="Muyan">Muyan</a>
        <a class="site-index current" href="/"><i class="fa fa-home"></i><span>首页</span></a>
        <a href="/archives/" title="归档"><i class="fa fa-archives"></i><span>归档</span></a>
        <a href="/tags/" title="标签"><i class="fa fa-tags"></i><span>标签</span></a>
        <!-- <a href="/rss" title="RSS Feed"><i class="fa fa-rss"></i><span>RSS Feed</span></a> -->
        <a href="/tags/悦读/" title="悦读"><i class="fa fa-book"></i><span>悦读</span></a>
        <a href="/tags/图集/" title="图集"><i class="fa fa-photo"></i><span>图集</span></a>
        <a href="/music/" title="音乐"><i class="fa fa-music"></i><span>音乐</span></a>
        <a href="/video/" title="视频"><i class="fa fa-video-camera"></i><span>视频</span></a>
        <a href="/tags/资源/" title="资源"><i class="fa fa-cloud"></i><span>资源</span></a>
        <a href="/links/" title="友链"><i class="fa fa-link"></i><span>友链</span></a>
        <!-- 签到 -->
        <!-- <a href="/2018/08/06/言念君子，温其如玉/" title="签到"><i class="fa fa-hand-peace-o"></i><span>签到</span></a> -->
        <a href="/help/" title="关于"><i class="fa fa-question-circle"></i><span>关于</span></a>
        <!-- <div id="player2" class="aplayer" style="position: absolute; bottom:0px; width:45px; height:45px; margin:0px;" class="aplayer"></div> -->
    </nav>
        <!--<div id="player5" class="aplayer" style="position: fixed; bottom:0px; width:100%; height:auto; margin:0px;" class="aplayer"></div>--!>
</div>
<div class="nav-user">
    <a class="btn-search" href="#"><i class="fa fa-search"></i></a>
    <a class="btn-read-mode" href="#"><i class="fa fa-sun-o"></i></a>
    <a class="btn-weixin-mp" target="_blank" rel="noopener" href="http://author.baidu.com/home/1594654793276567"><i class="fa fa-paw"></i></a>
</div>
<div id="wrapper" class="clearfix">
    <div id="body">
        <div class="main" id="main">
            <div id="cover">
    <div class="cover-img"></div>
    <div class="cover-info">
        <a href="/about/MuyanGit.html"><img title="言念君子，温其如玉" class="avatar" width="72" src="https://cdn.jsdelivr.net/gh/MuyanGit/ImageHosting/images/剑来大小抠图/bitbug_favicon大.ico" alt="avatar" /></a>
        <h1>MuyanGit</h1>
        <h3>hello ，stranger</h3>
        <p>言念君子，温其如玉</p>
        <div class="cover-sns">
            <div class="btn btn-weixin">
                <a class="" href="javascript:"><i class="fa fa-weixin"></i></a>
                <div class="qrcode"><img src="https://cdn.jsdelivr.net/gh/MuyanGit/ImageHosting/sina/006bYVyvgy1ftan8chgw0j302s02s3yh.jpg" alt="weixinQrcode" /></div>
                <div class="qrcode-arrow"></div>
            </div>
            <div class="btn btn-weibo">
                <a href="https://weibo.com/5673857615/profile?topnav=1&amp;wvr=6&amp;is_all=1" target="_blank" rel="nofollow"><i class="fa fa-weibo"></i></a>
            </div>
            <div class="btn btn-qq">
                <a href="https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes"  target="_blank" rel="nofollow"><i class="fa fa-qq"></i></a>
            </div>
            <div class="btn btn-github">
                <a href="https://github.com/honjun"  target="_blank" rel="nofollow"><i class="fa fa-github"></i></a>
            </div>
            <div class="btn btn-bili">
                <a href="https://space.bilibili.com/271849279/#/"  target="_blank" rel="nofollow"><i class="iconfont icon-bilibili"></i></a>
            </div>
        </div>
    </div>
</div>
            <div class="page-title">
    <ul>
        <li><a href="/">首页</a></li>
        
        <li class="">
            <a href="/categories/tech" data-name="技术">技术</a>
        </li>
        
        <li class="">
            <a href="/categories/live" data-name="生活">生活</a>
        </li>
        
        <li class="">
            <a href="/links/" data-name="友情链接">友链</a>
        </li>
        <li class="page-search">
    <form id="search" class="search-form">
        <label for="s" class="sr-only">请输入关键字</label>
        <input class="search-field" type="text" name="s" class="text" placeholder="请输入关键字" />
        <button type="submit" class="search-form-submit" title="搜索"><i class="fa fa-search"></i></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            // PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
</li>

    </ul>
</div>
<div class="main-inner">
    <article class="post" itemscope itemtype="http://www.hojun.cn">
        <div class="post-header">
            <div class="post-author clearfix">
                <a class="avatar fleft" href="/about/MuyanGit.html" target="_blank">
                    <img width="48" src="https://cdn.jsdelivr.net/gh/MuyanGit/ImageHosting/images/favicon.ico" alt="avatar"/>
                </a>
                <p><span class="label">作者</span>
                    <span>MuyanGit</span>
                    <span title="最后编辑于2022-06-08">2022-06-08</span>
                </p>
                <p>尽小者大，慎微者著</p>
            </div>
            <h2 class="post-title">Windows桌面程序自动化控制之uiautomation模块全面讲解</h2>
            <div class="post-meta">
                本文总共59011个字 | 您是第<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>位看到它们的小伙伴
            </div>
        </div>
        <div class="post-content markdown-body">
            <p>代码网</p>
<ul>
<li>首页</li>
<li>博客</li>
<li>专栏</li>
</ul>
<p>写博客<a href="javascript:void(0)">登录/注册</a></p>
<p><a href="javascript:void(0)">创作</a></p>
<p><a href="javascript:void(0)">700</a></p>
<p><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296#comment">0</a></p>
<p><a href="javascript:void(0)">收藏</a></p>
<p><strong>Windows桌面程序自动化控制之uiautomation模块全面讲解</strong></p>
<p>tjk </p>
<p> 2021-11-19 11:21:52 </p>
<p> 700 </p>
<p> 0 </p>
<p>大家好，我是小小明，经过2个月断断续续的整理，uiautomation模块桌面自动化控制的系统教程终于成型出炉了。下面是本文档的目录大纲，大家可以感受一下：</p>
<h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">简介</a></li>
<li></li>
<li></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">功能介绍</a></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">基本原理</a></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">控件控制入门：记事本操作</a></li>
<li></li>
<li></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">控件分析与可用参数</a></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">控件延迟搜索机制</a></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">示例：连续打开三个记事本并关闭</a></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">UIAutomation的常见功能</a></li>
<li></li>
<li></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">基本方法</a></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">获取窗口对象</a></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">控件查找方法</a></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">窗口属性调整</a></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">WalkTree遍历子控件</a></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">Bitmap位图对象的使用</a></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">对多个显示器分别截屏</a></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">剪切板操作</a></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">自带的Logger日志输出类</a></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">全局热键与多线程</a></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">管理员提权</a></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">通过实例学习UI自动化</a></li>
<li></li>
<li></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">控制win10计算器自动计算</a></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">窗口的拖拽与缩放</a></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">管理员提权操作并读取设备管理器栏目数据</a></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">记事本文本输入与字体调整</a></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">wireshark抓包数据读取</a></li>
<li></li>
<li><a target="_blank" rel="noopener" href="https://www.daima.net/blog/d6acb36960f64c9b98babcf538797296">PDF目录折叠展开提取器</a></li>
</ul>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="深度：斜杠数量-1"><a href="#深度：斜杠数量-1" class="headerlink" title="深度：斜杠数量+1"></a>深度：斜杠数量+1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save_Window=  auto.WindowControl(searchDepth=3, ClassName=&#x27;#32770&#x27;)</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/MuyanGit/pic_url/master/img/image-20220610173600286.png" alt="image-20220610173600286"></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>本文档大纲：</p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_0.png?x-oss-process=style/watermark" alt="image-20211118101343337"></p>
<p>可以看到uiautomation模块除了核心功能UI控件的<strong>控制</strong>、<strong>截图</strong>和<strong>数据提取</strong>外，还支持<strong>全局热键注册</strong>、<strong>剪切板操作</strong>和<strong>管理员权限提权</strong>。</p>
<p>在常规的模拟鼠标和键盘操作，我们一般使用<strong>pyautogui</strong>，uiautomation模块不仅能直接支持这些操作，还能通过控件定位方式直接定位到目标控件的位置，而不需要自己去获取对应坐标位置。uiautomation模块不仅支持任意坐标位置截图，还支持目标控件的截图，缺点在于截取产生的图片对象难以直接与PIL库配合，只能导出文件后让PIL图像处理库重新读取。对于能够获取到其ScrollItemPattern对象的控件还可以通过ScrollIntoView方法进行视图定位，与游览器的元素定位效果几乎一致。</p>
<p>在常规的热键功能，我们一般使用pynput实现，但现在有了uiautomation模块，热键注册会比pynput更简单功能更强。uiautomation模块所支持的剪切板操作的功能也远远超过常规的专门用于剪切板复制粘贴的库。更牛的是uiautomation模块能直接支持让你的python程序实现管理员提权。</p>
<p>基本上这个库的功能超过好几个专门针对某个功能的库。我们可以看看一下这个库自动化操作过程的动图效果：</p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_15.gif" alt="请添加图片描述"></p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_17.gif" alt="请添加图片描述"></p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_19.gif" alt="请添加图片描述"></p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_21.gif" alt="请添加图片描述"></p>
<p>掌握这个框架之后，你能够实现的自动化效果远不止如此。</p>
<p>这么优秀的框架你是否心动了呢？心动不如行动，学起来吧！！！</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>uiautomation模块项目地址：<a target="_blank" rel="noopener" href="https://github.com/yinkaisheng/Python-UIAutomation-for-Windows">https://github.com/yinkaisheng/Python-UIAutomation-for-Windows</a></p>
<blockquote>
<p>uiautomation是yinkaisheng业余时间开发一个模块。封装了微软UIAutomation API，支持自动化Win32，MFC，WPF，Modern UI(Metro UI), Qt, IE, Firefox(version&lt;=56 or &gt;=60), Chrome谷歌游览器和基于Electron开发的应用程序(加启动参数–force-renderer-accessibility也能支持UIAutomation被自动化). uiautomation只支持Python 3版本，依赖comtypes和typing这两个包，但Python不要使用3.7.6和3.8.1这两个版本，comtypes在这两个版本中不能正常工作（issue）。</p>
</blockquote>
<p><strong>UIAutomation的工作原理：</strong></p>
<p>UIAutomation操作程序时会给程序发送WM_GETOBJECT消息，如果程序处理WM_GETOBJECT消息，实现UI Automation Provider,并调用函数</p>
<p>**UiaReturnRawElementProvider(HWND hwnd,WPARAM wparam,LPARAM lparam,IRawElementProviderSimple *el)**，此程序就支持UIAutomation。</p>
<p>IRawElementProviderSimple 就是 UI Automation Provider，包含了控件的各种信息，如Name，ClassName，ContorlType，坐标等。</p>
<p>UIAutomation 根据程序返回的 IRawElementProviderSimple，就能遍历程序的控件，得到控件各种属性，进行自动化操作。若程序没有处理WM_GETOBJECT或没有实现UIAutomation Provider，UIAutomation则无法识别这些程序内的控件，不支持自动化。</p>
<p>很多DirectUI程序没有实现UIAutomation Provider，所以不支持自动化。</p>
<p>关于各控件所支持的控件模式，可参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/winauto/uiauto-controlpatternmapping">https://docs.microsoft.com/zh-cn/windows/win32/winauto/uiauto-controlpatternmapping</a></p>
<p>在使用uiautomation模块前需要先安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install uiautomation</span><br></pre></td></tr></table></figure>

<p>安装后会在python安装目录下的Scripts目录下得到一个automation.py脚本，可以使用它来准确获取目标窗口的控件结构信息。</p>
<p>automation.py脚本也可以从<a target="_blank" rel="noopener" href="https://github.com/yinkaisheng/Python-UIAutomation-for-Windows/raw/master/automation.py%E4%B8%8B%E8%BD%BD%E3%80%82">https://github.com/yinkaisheng/Python-UIAutomation-for-Windows/raw/master/automation.py下载。</a></p>
<p>当然使用windows自带的inspect.exe图形化工具来观察控件的树形结构更加，通过everything可以很快在系统中找到该工具。</p>
<blockquote>
<p>⚠️ ：inspect.exe工具获取到的控件类型可能与automation.py脚本打印的结果不太一样，如果发现控件实际不存在，要以automation.py脚本打印的结果为准。</p>
</blockquote>
<h1 id="控件控制入门：记事本操作"><a href="#控件控制入门：记事本操作" class="headerlink" title="控件控制入门：记事本操作"></a>控件控制入门：记事本操作</h1><h2 id="控件分析与可用参数"><a href="#控件分析与可用参数" class="headerlink" title="控件分析与可用参数"></a>控件分析与可用参数</h2><p>首先打开记事本窗口，并设置窗口前置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">import uiautomation as auto</span><br><span class="line"></span><br><span class="line">subprocess.Popen(&#x27;notepad.exe&#x27;)</span><br><span class="line"># 从桌面的第一层子控件中找到记事本程序的窗口WindowControl</span><br><span class="line">notepadWindow = auto.WindowControl(searchDepth=1, ClassName=&#x27;Notepad&#x27;)</span><br><span class="line">print(notepadWindow.Name)</span><br><span class="line"># 设置窗口前置</span><br><span class="line">notepadWindow.SetTopmost(True)</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>

<p>运行上述代码后，会打开一个窗口前置的记事本程序。</p>
<p>控件可用参数说明：</p>
<ul>
<li></li>
<li><p><strong>searchFromControl = None</strong>：从哪个控件开始查找，如果为None，从根控件Desktop开始查找</p>
</li>
<li></li>
<li><p><strong>searchDepth = 0xFFFFFFFF</strong>： 搜索深度</p>
</li>
<li></li>
<li><p><strong>searchInterval = SEARCH_INTERVAL</strong>：搜索间隔</p>
</li>
<li></li>
<li><p><strong>foundIndex = 1</strong> ：搜索到的满足搜索条件的控件索引，索引从1开始</p>
</li>
<li></li>
<li><p><strong>Name</strong>：控件名字</p>
</li>
<li></li>
<li><p><strong>SubName</strong> ：控件部分名字</p>
</li>
<li></li>
<li><p><strong>RegexName</strong>：使用re.match匹配符合正则表达式的名字，Name,SubName,RegexName只能使用一个，不能同时使用</p>
</li>
<li></li>
<li><p><strong>ClassName</strong> ：类名字</p>
</li>
<li></li>
<li><p><strong>AutomationId</strong>： 控件AutomationId</p>
</li>
<li></li>
<li><p><strong>ControlType</strong> ：控件类型</p>
</li>
<li></li>
<li><p><strong>Depth</strong>：控件相对于searchFromControl的精确深度</p>
</li>
<li></li>
<li><p><strong>Compare</strong>：自定义比较函数function(control: Control, depth: int)-&gt;bool</p>
</li>
<li></li>
</ul>
<p><strong>searchDepth和Depth的区别：</strong></p>
<blockquote>
<p>searchDepth在指定的深度范围内（包括1<del>searchDepth层中的所有子孙控件）搜索第一个满足搜索条件的控件 Depth只在Depth所在的深度（如果Depth&gt;1，排除1</del>searchDepth-1层中的所有子孙控件）搜索第一个满足搜索条件的控件</p>
</blockquote>
<p>为了进一步操作该程序，我们可以使用inspect.exe工具或automation.py脚本分析控件结构。</p>
<p>通过inspect.exe工具分析控件时可以看到记事本的编辑区类型为DocumentControl：</p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_5.png?x-oss-process=style/watermark" alt="image-20210921164143136"></p>
<p>但uiautomation实际使用该类型查找控件时却会找不到控件报错。</p>
<p>下面我们使用automation.py脚本来分析目标窗口，我的Python安装目录为D:\Miniconda3所以automation.py脚本会存在于D:\Miniconda3\Scripts\automation.py</p>
<p>查看帮助信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;python D:\Miniconda3\Scripts\automation.py -h</span><br><span class="line">UIAutomation 2.0.15 (Python 3.7.4, 64 bit)</span><br><span class="line">usage</span><br><span class="line">-h      show command help</span><br><span class="line">-t      delay time, default 3 seconds, begin to enumerate after Value seconds, this must be an integer</span><br><span class="line">        you can delay a few seconds and make a window active so automation can enumerate the active window</span><br><span class="line">-d      enumerate tree depth, this must be an integer, if it is null, enumerate the whole tree</span><br><span class="line">-r      enumerate from root:Desktop window, if it is null, enumerate from foreground window</span><br><span class="line">-f      enumerate from focused control, if it is null, enumerate from foreground window</span><br><span class="line">-c      enumerate the control under cursor, if depth is &lt; 0, enumerate from its ancestor up to depth</span><br><span class="line">-a      show ancestors of the control under cursor</span><br><span class="line">-n      show control full name, if it is null, show first 30 characters of control&#x27;s name in console,</span><br><span class="line">        always show full name in log file @AutomationLog.txt</span><br><span class="line">-p      show process id of controls</span><br><span class="line"></span><br><span class="line">if UnicodeError or LookupError occurred when printing,</span><br><span class="line">try to change the active code page of console window by using chcp or see the log file @AutomationLog.txt</span><br><span class="line">chcp, get current active code page</span><br><span class="line">chcp 936, set active code page to gbk</span><br><span class="line">chcp 65001, set active code page to utf-8</span><br><span class="line"></span><br><span class="line">examples:</span><br><span class="line">automation.py -t3</span><br><span class="line">automation.py -t3 -r -d1 -m -n</span><br><span class="line">automation.py -c -t3</span><br><span class="line">12345678910111213141516171819202122</span><br></pre></td></tr></table></figure>

<p>下面为了后续命令简化一点，我先将automation.py文件复制到cmd所在的当前目录。</p>
<p>执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python automation.py -t1 -d1</span><br></pre></td></tr></table></figure>

<p>立马在1秒内将鼠标激活记事本窗口，可以看到控制台打印：</p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_6.png?x-oss-process=style/watermark" alt="image-20210921170002665"></p>
<p>可以看到第一个控件的类型为EditControl。</p>
<p>下面将鼠标移动到记事本的编辑框内之后，执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python automation.py -t0 -c</span><br></pre></td></tr></table></figure>

<p>就得到编辑器的全部子控件信息：</p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_7.png?x-oss-process=style/watermark" alt="image-20210921170648813"></p>
<p>conda中注意激活 activate p38</p>
<p><img src="https://raw.githubusercontent.com/MuyanGit/pic_url/master/img/image-20220608153123108.png" alt="image-20220608153123108"></p>
<p>下面我们使用uiautomation向记事本输入文本。</p>
<p>首先获取输入框：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit = notepadWindow.EditControl()</span><br></pre></td></tr></table></figure>

<p><strong>方法1</strong>-使用EditControl支持的ValuePattern：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit.GetValuePattern().SetValue(&#x27;方法1&#x27;)</span><br></pre></td></tr></table></figure>

<p>该方法直接修改编辑框的文本内容。</p>
<p><strong>方法2</strong>-发送按键指令输入文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit.SendKeys(&#x27;方法2&#x27;)</span><br></pre></td></tr></table></figure>

<p>该方法的输入效果比较像打字机输入。</p>
<p><strong>方法3</strong>-复制文本后到剪切板粘贴：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto.SetClipboardText(&quot;方法3&quot;)</span><br><span class="line">edit.SendKeys(&#x27;&#123;Ctrl&#125;v&#x27;)</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>获取当前编辑框中的文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(edit.GetValuePattern().Value)</span><br></pre></td></tr></table></figure>

<p>最后我们点击标题栏的关闭按钮（可以通过索引或名称查找目标按钮）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 通过标题栏第三个按钮找到关闭按钮</span><br><span class="line">notepadWindow.TitleBarControl(Depth=1).ButtonControl(foundIndex=3).Click()</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>或：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 通过标题栏查找名称为关闭的按钮</span><br><span class="line">notepadWindow.TitleBarControl(Depth=1).ButtonControl(searchDepth=1, Name=&#x27;关闭&#x27;).Click()</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>最后保存并关闭：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">notepadWindow.TitleBarControl(Depth=1).ButtonControl(searchDepth=1, Name=&#x27;关闭&#x27;).Click()</span><br><span class="line"># 确认保存</span><br><span class="line">auto.SendKeys(&#x27;&#123;ALT&#125;s&#x27;)</span><br><span class="line"># 输入文件名，并快捷键点击保存</span><br><span class="line">auto.SendKeys(&#x27;自动保存&#123;ALT&#125;s&#x27;)</span><br><span class="line"># 如果弹出文件名冲突提示，则确认覆盖</span><br><span class="line">auto.SendKeys(&#x27;&#123;ALT&#125;y&#x27;)</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<p><strong>完整代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">import uiautomation as auto</span><br><span class="line"></span><br><span class="line">subprocess.Popen(&#x27;notepad.exe&#x27;)</span><br><span class="line"># 首先从桌面的第一层子控件中找到记事本程序的窗口WindowControl，再从这个窗口查找子控件</span><br><span class="line">notepadWindow = auto.WindowControl(searchDepth=1, ClassName=&#x27;Notepad&#x27;)</span><br><span class="line">print(notepadWindow.Name)</span><br><span class="line"># 设置窗口前置</span><br><span class="line">notepadWindow.SetTopmost(True)</span><br><span class="line"># 输入文本</span><br><span class="line">edit = notepadWindow.EditControl()</span><br><span class="line">auto.SetClipboardText(&quot;WIN98中的“98”是什么意思？&quot;)</span><br><span class="line">edit.SendKeys(&#x27;&#123;Ctrl&#125;v&#x27;)</span><br><span class="line"># 获取文本</span><br><span class="line">print(&quot;编辑框内容：&quot;,edit.GetValuePattern().Value)</span><br><span class="line"># 通过标题栏查找名称为关闭的按钮</span><br><span class="line">notepadWindow.TitleBarControl(Depth=1).ButtonControl(searchDepth=1, Name=&#x27;关闭&#x27;).Click()</span><br><span class="line"># 确认保存</span><br><span class="line">auto.SendKeys(&#x27;&#123;ALT&#125;s&#x27;)</span><br><span class="line"># 输入文件名，并快捷键点击保存</span><br><span class="line">auto.SendKeys(&#x27;自动保存&#123;ALT&#125;s&#x27;)</span><br><span class="line"># 如果弹出文件名冲突提示，则确认覆盖</span><br><span class="line">auto.SendKeys(&#x27;&#123;ALT&#125;y&#x27;)</span><br><span class="line">123456789101112131415161718192021</span><br></pre></td></tr></table></figure>

<h2 id="控件延迟搜索机制"><a href="#控件延迟搜索机制" class="headerlink" title="控件延迟搜索机制"></a>控件延迟搜索机制</h2><p>底层COM对象方法：</p>
<blockquote>
<p>⚠️ Control.Element返回IUIAutomation底层COM对象IUIAutomationElement， 基本上Control的所有属性或方法都是通过调用IUIAutomationElement COM API和Win32 API实现的。</p>
</blockquote>
<p>延迟搜索控件：</p>
<blockquote>
<p>当我们创建一个Control对象时，uiautomation并不会马上开始搜索控件，而是当使用其属性或方法，并且内部的Control.Element是None时uiautomation才开始搜索控件。如果在uiautomation.TIME_OUT_SECOND(默认为10)秒内找不到控件，uiautomation就会抛出一个LookupError异常。</p>
</blockquote>
<p>也可以调用Control.Refind立马或重新开始搜索控件，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">edit = notepadWindow.EditControl()</span><br><span class="line">edit.Refind()</span><br><span class="line">1</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>但是当控件不存在时，则会报出错误。</p>
<p>为了避免函数最终抛出异常，可以调用Control.Exists(maxSearchSeconds, searchIntervalSeconds, printIfNotExist)检查目标控件是否存在：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">edit = notepadWindow.EditControl()</span><br><span class="line">edit.Exists()</span><br><span class="line">1</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Control.Refind和Control.Exists均会使Control.Element无效并触发重新搜索逻辑。</p>
</blockquote>
<p>另一种检查目标控件是否存在的方法是auto.WaitForExist(control, timeout)。</p>
<p>下面继续以记事本为对象演示这个机制。首先打开第一个记事本并获取输入控件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">import uiautomation as auto</span><br><span class="line">auto.uiautomation.SetGlobalSearchTimeout(2)  # 设置全局搜索超时时间为2秒</span><br><span class="line"></span><br><span class="line">subprocess.Popen(&#x27;notepad.exe&#x27;)</span><br><span class="line">window = auto.WindowControl(searchDepth=1, ClassName=&#x27;Notepad&#x27;)</span><br><span class="line"># 创建控件对象时并不会开始搜索控件</span><br><span class="line">edit = window.EditControl()</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<p>此时，控件window和edit还没有开始搜索，内部Control.Element的值为None。</p>
<p>第一次调用SendKeys时，才开始搜索控件window和edit：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 第一次调用SendKeys时, 才开始搜索控件window和edit</span><br><span class="line">edit.SendKeys(&#x27;第一次调用&#x27;)</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>搜索完毕后，才会开始执行发送按键方法，此时Control.Element有效。</p>
<p>第二次调用SendKeys不会触发搜索（Control.Element不为None）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit.SendKeys(&#x27;第二次调用&#x27;)</span><br></pre></td></tr></table></figure>

<p>然后我们清空输入的内容，并关闭刚才打开的记事本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">edit.GetValuePattern().SetValue(&#x27;&#x27;)</span><br><span class="line">window.GetWindowPattern().Close()</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>关闭后，此时虽然window和edit有值却已经无效了。</p>
<p>再次打开记事本，就必须重新搜索控件（否则无法操作新启动的窗口）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">subprocess.Popen(&#x27;notepad.exe&#x27;)  # 运行第二个Notepad</span><br><span class="line">window.Refind()  # 必须重新搜索</span><br><span class="line">edit.Refind()  # 必须重新搜索</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>然后可以将其关闭：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.GetWindowPattern().Close()</span><br></pre></td></tr></table></figure>

<p>window和edit的Element再次失效。</p>
<p>Exists方法则既可以判断控件是否存在，也可以触发重新搜索：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">subprocess.Popen(&#x27;notepad.exe&#x27;)  # 运行第三个Notepad</span><br><span class="line">if window.Exists(maxSearchSeconds=1.5, searchIntervalSeconds=0.3):  # 触发重新搜索</span><br><span class="line">    if edit.Exists(maxSearchSeconds=1.5):  # 触发重新搜索</span><br><span class="line">        edit.SendKeys(&#x27;third notepad&#x27;)  # 之前的Exists保证edit.Element有效</span><br><span class="line">        edit.SendKeys(&#x27;&#123;Ctrl&#125;a&#123;Del&#125;&#x27;)</span><br><span class="line">    window.GetWindowPattern().Close()</span><br><span class="line">else:</span><br><span class="line">    print(&quot;窗口1.5秒内未找到&quot;)</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>

<h2 id="示例：连续打开三个记事本并关闭"><a href="#示例：连续打开三个记事本并关闭" class="headerlink" title="示例：连续打开三个记事本并关闭"></a>示例：连续打开三个记事本并关闭</h2><p>完整代码与注释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">import uiautomation as auto</span><br><span class="line"># 设置全局搜索超时2秒</span><br><span class="line">auto.uiautomation.SetGlobalSearchTimeout(2)  </span><br><span class="line"></span><br><span class="line">subprocess.Popen(&#x27;notepad.exe&#x27;)</span><br><span class="line">window = auto.WindowControl(searchDepth=1, ClassName=&#x27;Notepad&#x27;)</span><br><span class="line">window.SetTopmost(True)</span><br><span class="line">edit = window.EditControl()</span><br><span class="line"># 当第一次调用SendKeys时, uiautomation开始在2秒内搜索控件window和edit</span><br><span class="line"># 因为SendKeys内部会间接调用Control.Element并且Control.Element值是None</span><br><span class="line"># 如果在15秒内找不到window和edit，会抛出LookupError异常</span><br><span class="line">try:</span><br><span class="line">    edit.SendKeys(&#x27;第一个记事本程序&#x27;)</span><br><span class="line">except LookupError as ex:</span><br><span class="line">    print(&quot;第一个记事本窗口在2秒内未找到&quot;)</span><br><span class="line"></span><br><span class="line"># 第二次调用SendKeys不会触发搜索, 之前的调用保证Control.Element有效</span><br><span class="line">edit.SendKeys(&#x27;&#123;Ctrl&#125;a&#123;Del&#125;&#x27;)</span><br><span class="line"># 关闭第一个Notepad, window和edit的Element虽然有值，但是无效了</span><br><span class="line">window.GetWindowPattern().Close()</span><br><span class="line"></span><br><span class="line">subprocess.Popen(&#x27;notepad.exe&#x27;)  # 运行第二个Notepad</span><br><span class="line">window.Refind()  # 必须重新搜索</span><br><span class="line">edit.Refind()  # 必须重新搜索</span><br><span class="line">edit.SendKeys(&#x27;第二个记事本程序&#x27;)</span><br><span class="line">edit.SendKeys(&#x27;&#123;Ctrl&#125;a&#123;Del&#125;&#x27;)</span><br><span class="line">window.GetWindowPattern().Close()  # 关闭第二个Notepad, window和edit的Element虽然有值，但是再次无效了</span><br><span class="line"></span><br><span class="line">subprocess.Popen(&#x27;notepad.exe&#x27;)  # 运行第三个Notepad</span><br><span class="line">if window.Exists(3, 1):  # 触发重新搜索</span><br><span class="line">    if edit.Exists(3):  # 触发重新搜索</span><br><span class="line">        edit.SendKeys(&#x27;第三个记事本程序&#x27;)  # 之前的Exists保证edit.Element有效</span><br><span class="line">        edit.SendKeys(&#x27;&#123;Ctrl&#125;a&#123;Del&#125;&#x27;)</span><br><span class="line">    window.GetWindowPattern().Close()</span><br><span class="line">else:</span><br><span class="line">    print(&quot;第三个记事本程序在三秒内不存在&quot;)</span><br><span class="line">1234567891011121314151617181920212223242526272829303132</span><br></pre></td></tr></table></figure>

<h1 id="UIAutomation的常见功能"><a href="#UIAutomation的常见功能" class="headerlink" title="UIAutomation的常见功能"></a>UIAutomation的常见功能</h1><p>导包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import uiautomation as auto</span><br></pre></td></tr></table></figure>

<h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><p><strong>显示桌面（相当于点击桌面右下角的按钮）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto.ShowDesktop()</span><br></pre></td></tr></table></figure>

<p><strong>获取uiautomation已运行的时间：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto.ProcessTime()</span><br></pre></td></tr></table></figure>

<p><strong>判断两个控件是否一致：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto.ControlsAreSame(control1, control2)</span><br></pre></td></tr></table></figure>

<p><strong>鼠标点击指定坐标：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto.Click(x, y)</span><br></pre></td></tr></table></figure>

<p><strong>右键单击：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto.RightClick(x, y)</span><br></pre></td></tr></table></figure>

<p><strong>鼠标拖拽(鼠标从(x1,y1)位置按下鼠标拖动到(x2,y2)位置)：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto.DragDrop(x1, y1, x2, y2, moveSpeed=1)</span><br></pre></td></tr></table></figure>

<p>moveSpeed参数决定了移动的速度。</p>
<p>关于鼠标滚轮操作详见后面的实例，被找到的控件调用鼠标点击方法不需要传入坐标。</p>
<h2 id="获取窗口对象"><a href="#获取窗口对象" class="headerlink" title="获取窗口对象"></a>获取窗口对象</h2><p>获取桌面对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = auto.GetRootControl()</span><br></pre></td></tr></table></figure>

<p>返回运行当前python程序的控制台窗口对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmdWindow = auto.GetConsoleWindow()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>没有找到则返回None。</p>
</blockquote>
<p>获取当前鼠标位置对应的窗口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = auto.ControlFromCursor().GetTopLevelControl()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ControlFromCursor返回了当前鼠标位置的控件，GetTopLevelControl获取了该控件对应的顶级窗口对象。</p>
</blockquote>
<p>获取当前激活窗口对应的对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = auto.GetForegroundControl().GetTopLevelControl()</span><br></pre></td></tr></table></figure>

<h2 id="控件查找方法"><a href="#控件查找方法" class="headerlink" title="控件查找方法"></a>控件查找方法</h2><p>获取所有的子控件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control.GetChildren()</span><br></pre></td></tr></table></figure>

<p>获取首个子控件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control.GetFirstChildControl()</span><br></pre></td></tr></table></figure>

<p>获取最后一个子控件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control.GetLastChildControl()</span><br></pre></td></tr></table></figure>

<p>获取下一个兄弟控件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control.GetNextSiblingControl()</span><br></pre></td></tr></table></figure>

<p>获取前一个兄弟控件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control.GetPreviousSiblingControl()</span><br></pre></td></tr></table></figure>

<p>获取父控件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control.GetParentControl()</span><br></pre></td></tr></table></figure>

<p>获取顶层窗口控件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control.GetTopLevelControl()</span><br></pre></td></tr></table></figure>

<p>获取满足指定条件的祖先控件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control.GetAncestorControl(func)</span><br></pre></td></tr></table></figure>

<p>传入的函数参数要求：function(control: Control, depth: int) -&gt; bool</p>
<p>当函数返回True时表示找到控件并返回，例如以下方法几乎可以得与GetTopLevelControl()相同的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control.GetAncestorControl(lambda c, d: isinstance(c, auto.WindowControl))</span><br></pre></td></tr></table></figure>

<h2 id="窗口属性调整"><a href="#窗口属性调整" class="headerlink" title="窗口属性调整"></a>窗口属性调整</h2><p><strong>假设获取到一个窗口对象：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win = auto.ControlFromCursor().GetTopLevelControl()</span><br></pre></td></tr></table></figure>

<p><strong>获取本地窗口句柄：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win.NativeWindowHandle</span><br></pre></td></tr></table></figure>

<p><strong>根据本地窗口句柄获取窗口控件对象：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win2 = auto.ControlFromHandle(win.NativeWindowHandle)</span><br></pre></td></tr></table></figure>

<p>经测试，对象一致：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto.ControlsAreSame(win, win2)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p><strong>隐藏窗口：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win.Hide(0)</span><br></pre></td></tr></table></figure>

<p><strong>显示窗口：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win.Show(0)</span><br></pre></td></tr></table></figure>

<p><strong>窗口最小化：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win.Minimize()</span><br></pre></td></tr></table></figure>

<p><strong>窗口最大化：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win.Maximize()</span><br></pre></td></tr></table></figure>

<p><strong>判断窗口是否已经被最小化：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto.IsIconic(win.NativeWindowHandle)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>IsIconic进支持传入本地窗口句柄。</p>
</blockquote>
<p><strong>将最小化的窗口的恢复显示：</strong></p>
<p><strong>修改窗口的位置和大小</strong>，例如将某个窗口调整到最后一个屏幕的一半：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rects = auto.GetMonitorsRect()</span><br><span class="line">rect = rects[-1]</span><br><span class="line">win.MoveWindow(rect.left, rect.top,</span><br><span class="line">               rect.width()//2, rect.height()-30)</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>不过这种调整方法对于cmd这种命令行窗口无效，只能在获取其TransformPattern对象后，调用<strong>Move</strong>和<strong>Resize</strong>方法来实现。上面的MoveWindow等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transform_win = win.GetTransformPattern()</span><br><span class="line">transform_win.Move(rect.left, rect.top)</span><br><span class="line">transform_win.Resize(rect.width()//2, rect.height()-30)</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p><strong>移动窗口到屏幕中心位置：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win.MoveToCenter()</span><br></pre></td></tr></table></figure>

<p><strong>窗口置顶：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.SetTopmost(True)</span><br></pre></td></tr></table></figure>

<p><strong>获取窗口标题并修改窗口标题：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win.SetWindowText(win.GetWindowText()+&quot;|小小明&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>获取运行当前python程序控制台窗口的标题：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto.GetConsoleTitle()</span><br><span class="line"># auto.GetConsoleOriginalTitle()</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong>设置运行当前python程序控制台窗口的标题：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto.SetConsoleTitle(&#x27;自定义控制台标题&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="WalkTree遍历子控件"><a href="#WalkTree遍历子控件" class="headerlink" title="WalkTree遍历子控件"></a>WalkTree遍历子控件</h2><p>除了auto.WalkTree遍历目标控件外，还有auto.WalkControl遍历控件，区别在于auto.WalkTree必须传入自定义函数指定遍历的行为。auto.WalkControl将会在后面涉及可折叠类型的控件遍历时进行演示，下面给出一个简单的通过WalkTree遍历桌面的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import uiautomation as auto</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def GetFirstChild(control):</span><br><span class="line">    return control.GetFirstChildControl()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def GetNextSibling(control):</span><br><span class="line">    return control.GetNextSiblingControl()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">desktop = auto.GetRootControl()</span><br><span class="line">for control, depth in auto.WalkTree(desktop, getFirstChild=GetFirstChild, getNextSibling=GetNextSibling,</span><br><span class="line">                                    includeTop=True, maxDepth=2):</span><br><span class="line">    if not control.Name:</span><br><span class="line">        continue</span><br><span class="line">    print(&#x27; &#x27; * depth * 4, control.Name)</span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure>

<p>maxDepth指定了遍历深度，除了指定这两个方法以外还可以只转入getChildren方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def GetChildren(control):</span><br><span class="line">    return control.GetChildren()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for control, depth, remain in auto.WalkTree(desktop,</span><br><span class="line">                                            getChildren=GetChildren,</span><br><span class="line">                                            includeTop=True,</span><br><span class="line">                                            maxDepth=2):</span><br><span class="line">    if not control.Name:</span><br><span class="line">        continue</span><br><span class="line">    print(&#x27; &#x27; * depth * 4, control.Name)</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>

<p>结果过滤的方逻辑我们还可以写到yieldCondition的传入函数中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def yieldCondition(control, depth):</span><br><span class="line">    if control.Name:</span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for control, depth, remain in auto.WalkTree(desktop,</span><br><span class="line">                                            getChildren=GetChildren,</span><br><span class="line">                                            yieldCondition=yieldCondition,</span><br><span class="line">                                            includeTop=True,</span><br><span class="line">                                            maxDepth=2):</span><br><span class="line">    print(&#x27; &#x27; * depth * 4, control.Name)</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>

<p>在我电脑当前执行结果均为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">桌面 1</span><br><span class="line">     任务栏</span><br><span class="line">         开始</span><br><span class="line">         在这里输入你要搜索的内容</span><br><span class="line">         开始</span><br><span class="line">         在这里输入你要搜索的内容</span><br><span class="line">         系统时钟, 23:02, ‎2021/‎11/‎15</span><br><span class="line">     test - Jupyter Notebook - 360安全浏览器 13.1</span><br><span class="line">         Chrome Legacy Window</span><br><span class="line">     一文掌握uiautomation的经典案例.md• - Typora</span><br><span class="line">         Typora</span><br><span class="line">     UIAutomation_demos – clipboard_test.py PyCharm</span><br><span class="line">     Program Manager</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure>

<p>WalkTree的规则是当设置getChildren函数时，忽略getFirstChild和getNextSibling，否则使用这两个函数。设置yieldCondition函数时则开启额外的过滤。</p>
<p>甚至可以<strong>使用WalkTree方法计算全排列问题：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def NextPermutations(aTuple):</span><br><span class="line">    left, permutation = aTuple</span><br><span class="line">    ret = []</span><br><span class="line">    for i, item in enumerate(left):</span><br><span class="line">        nextLeft = left[:]</span><br><span class="line">        del nextLeft[i]</span><br><span class="line">        nextPermutation = permutation + [item]</span><br><span class="line">        ret.append((nextLeft, nextPermutation))</span><br><span class="line">    return ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uniqueItems = list(&quot;abc&quot;)</span><br><span class="line">n = len(uniqueItems)</span><br><span class="line">count = 0</span><br><span class="line">for (left, permutation), depth, remain in auto.WalkTree((uniqueItems, []), NextPermutations,</span><br><span class="line">                                                        yieldCondition=lambda c, d: d == n):</span><br><span class="line">    count += 1</span><br><span class="line">    print(count, permutation)</span><br><span class="line">123456789101112131415</span><br><span class="line">1 [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br><span class="line">2 [&#x27;a&#x27;, &#x27;c&#x27;, &#x27;b&#x27;]</span><br><span class="line">3 [&#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;]</span><br><span class="line">4 [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;]</span><br><span class="line">5 [&#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;]</span><br><span class="line">6 [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>可以看到已经顺利的计算出正确的结果。</p>
<h2 id="Bitmap位图对象的使用"><a href="#Bitmap位图对象的使用" class="headerlink" title="Bitmap位图对象的使用"></a>Bitmap位图对象的使用</h2><p>默认新建的图片为空白透明图片：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">width, height = 500, 500</span><br><span class="line"># 创建一张透明图片</span><br><span class="line">bitmap = auto.Bitmap(width, height)</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>然后我们可以设置一点颜色，首先以逐像素遍历的方式操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">width, height = 500, 500</span><br><span class="line"># 创建一张透明图片</span><br><span class="line">bitmap = auto.Bitmap(width, height)</span><br><span class="line">start = auto.ProcessTime()</span><br><span class="line">for x in range(width):</span><br><span class="line">    for y in range(height):</span><br><span class="line">        color = ((x-width)**2+(y-height)**2)*255//(width**2+height**2)</span><br><span class="line">        bitmap.SetPixelColor(x, y, 0xFF00FF | color &lt;&lt; 24)</span><br><span class="line">cost = auto.ProcessTime() - start</span><br><span class="line">print(f&#x27;SetPixelColor 逐像素设置 &#123;width&#125;x&#123;height&#125; 图片的颜色耗时 &#123;cost:.3f&#125;s&#x27;)</span><br><span class="line">bitmap.ToFile(&#x27;tmp.png&#x27;)</span><br><span class="line">12345678910</span><br><span class="line">SetPixelColor 逐像素设置 500x500 图片的颜色耗时 0.648s</span><br></pre></td></tr></table></figure>

<p>上述代码遍历每个像素点，通过SetPixelColor方法设置颜色。可以看到耗时达到0.6秒以上，能否快一点呢？</p>
<p>SetPixelColorsOfRect方法可以直接设置整个区域的颜色：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">start = auto.ProcessTime()</span><br><span class="line">colors = []</span><br><span class="line">for x in range(width):</span><br><span class="line">    for y in range(height):</span><br><span class="line">        color = ((x-width)**2+(y-height)**2)*255//(width**2+height**2)</span><br><span class="line">        colors.append(0xFF00FF | color &lt;&lt; 24)</span><br><span class="line">bitmap.SetPixelColorsOfRect(0, 0, width, height, colors)</span><br><span class="line">cost = auto.ProcessTime() - start</span><br><span class="line">print(f&#x27;SetPixelColorsOfRect 设置 &#123;width&#125;x&#123;height&#125; 图片矩形区域的颜色，耗时 &#123;cost:.3f&#125;s&#x27;)</span><br><span class="line">bitmap.ToFile(&#x27;tmp.png&#x27;)</span><br><span class="line">123456789</span><br><span class="line">SetPixelColorsOfRect 设置 500x500 图片矩形区域的颜色，耗时 0.460s</span><br></pre></td></tr></table></figure>

<p>显然设置整个区域的颜色会更快一些。</p>
<p>经测试使用GetPixelColor方法获取到的颜色值可能会因为负数补码导致获取到的值与当初设置的不一致。我们可以通过GetAllPixelColors方法获取原生数组后，然后计算偏移量获取颜色值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">colors = bitmap.GetAllPixelColors()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getPixelColor(x, y):</span><br><span class="line">    return colors[x*width+y]</span><br><span class="line">    </span><br><span class="line">getPixelColor(10, 10)</span><br><span class="line">1234</span><br><span class="line">4110352639</span><br></pre></td></tr></table></figure>

<p>可以通过控件的ToBitmap方法对该控件截图获取Bitmap对象，传入参数可以决定截取的范围，例如我们截图桌面范围480*360范围内（不传参则获取整个控件）的图片：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root = auto.GetRootControl()</span><br><span class="line">bitmap = root.ToBitmap(0, 0, 480, 360)</span><br><span class="line">bitmap.ToFile(&#x27;tmp.png&#x27;)</span><br><span class="line">Image(&quot;tmp.png&quot;)</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_8.png?x-oss-process=style/watermark" alt="image-20211115214149137"></p>
<p>ToBitmap方法也可以使用Bitmap.FromControl方法替代：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitmap = auto.Bitmap.FromControl(control, x, y, width, height)</span><br></pre></td></tr></table></figure>

<p><strong>裁切图片：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">with bitmap.Copy(150, 100, 80, 102) as subBitmap:</span><br><span class="line">    subBitmap.ToFile(&#x27;tmp.png&#x27;)</span><br><span class="line">    display(Image(&quot;tmp.png&quot;))</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>结果：成功裁切出 极速PDF阅读器 的图标。</p>
<p>若需要<strong>同时裁切多个部分</strong>，可以使用GetPixelColorsOfRects方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">width, height = 75, 85</span><br><span class="line">rects = [((width*i, 0, width, height)) for i in range(3)]</span><br><span class="line">colors = bitmap.GetPixelColorsOfRects(rects)</span><br><span class="line">for nativeArray in colors:</span><br><span class="line">    with auto.Bitmap(width, height) as subBitmap:</span><br><span class="line">        subBitmap.SetPixelColorsOfRect(0, 0, width, height, nativeArray)</span><br><span class="line">        subBitmap.ToFile(&#x27;tmp.png&#x27;)</span><br><span class="line">        display(Image(&quot;tmp.png&quot;))</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>

<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_9.png?x-oss-process=style/watermark" alt="image-20211115215855714"></p>
<p><strong>X轴翻转：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">with bitmap.RotateFlip(auto.RotateFlipType.RotateNoneFlipX) as bmp:</span><br><span class="line">        bmp.ToFile(&#x27;tmp.png&#x27;)</span><br><span class="line">        display(Image(&quot;tmp.png&quot;))</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p><strong>Y轴翻转：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">with bitmap.RotateFlip(auto.RotateFlipType.RotateNoneFlipY) as bmp:</span><br><span class="line">    bmp.ToFile(&#x27;tmp.png&#x27;)</span><br><span class="line">    display(Image(&quot;tmp.png&quot;))</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p><strong>90度旋转：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">with bitmap.Rotate(90) as bmp:</span><br><span class="line">    bmp.ToFile(&#x27;tmp.png&#x27;)</span><br><span class="line">    display(Image(&quot;tmp.png&quot;))</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p><strong>30度旋转（非90度整数倍 旋转）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">with bitmap.Rotate(30) as bmp:</span><br><span class="line">    bmp.ToFile(&#x27;tmp.png&#x27;)</span><br><span class="line">    display(Image(&quot;tmp.png&quot;))</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_10.png?x-oss-process=style/watermark" alt="image-20211115220338272"></p>
<h2 id="对多个显示器分别截屏"><a href="#对多个显示器分别截屏" class="headerlink" title="对多个显示器分别截屏"></a>对多个显示器分别截屏</h2><p>结合前面的方法，我们可以对桌面截屏，对鼠标下的控件截屏，对当前激活窗口截屏等等。</p>
<p>基本都是在获取相应控件后调用如下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control.CaptureToImage(savePath)</span><br></pre></td></tr></table></figure>

<p>获取桌面控件前面已经演示，下面看看如何同时获取多个屏幕的截图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c = auto.GetRootControl()</span><br><span class="line">rects = auto.GetMonitorsRect()</span><br><span class="line">print(rects)</span><br><span class="line">for rect in rects:</span><br><span class="line">    c.CaptureToImage(&#x27;tmp.png&#x27;, rect.left, rect.top,</span><br><span class="line">                     rect.width(), rect.height())</span><br><span class="line">    display(Image(&quot;tmp.png&quot;))</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<p>核心点就是通过GetMonitorsRect获取所有屏幕的坐标范围数组，截图时指定坐标范围即可。</p>
<h2 id="剪切板操作"><a href="#剪切板操作" class="headerlink" title="剪切板操作"></a>剪切板操作</h2><p>通常我们会使用pyperclip对文本进行复制粘贴，但实际上uiautomation所支持的剪切板操作会更加丰富，不仅支持纯文本，还支持富文本和图片。</p>
<p>涉及文件的剪切板操作，个人已经在**<a target="_blank" rel="noopener" href="https://blog.csdn.net/as604049322/article/details/120631425">《UI自动化控制微信发送文件》</a>**一文中实现将文件设置到剪切板中。</p>
<p>获取当前剪切板的内容格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import uiautomation as auto</span><br><span class="line"></span><br><span class="line">formats = auto.GetClipboardFormats()</span><br><span class="line">print(formats)</span><br><span class="line">12</span><br><span class="line">&#123;49282: &#x27;HTML Format&#x27;, 49402: &#x27;Rich Text Format&#x27;, 13: &#x27;CF_UNICODETEXT&#x27;, 1: &#x27;CF_TEXT&#x27;, 49287: &#x27;UniformResourceLocator&#x27;, 50062: &#x27;JAVA_DATAFLAVOR:application/x-java-jvm-local-objectref; class=c&#x27;, 16: &#x27;CF_LOCALE&#x27;, 7: &#x27;CF_OEMTEXT&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>读取剪切板时，我们可以根据当前剪切板的格式分别作不同的处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">formats = auto.GetClipboardFormats()</span><br><span class="line">for k, v in formats.items():</span><br><span class="line">    if k == auto.ClipboardFormat.CF_UNICODETEXT:</span><br><span class="line">        print(&quot;文本格式：&quot;, auto.GetClipboardText())</span><br><span class="line">    elif k == auto.ClipboardFormat.CF_HTML:</span><br><span class="line">        htmlText = auto.GetClipboardHtml()</span><br><span class="line">        print(&quot;富文本格式：&quot;, htmlText)</span><br><span class="line">    elif k == auto.ClipboardFormat.CF_BITMAP:</span><br><span class="line">        bmp = auto.GetClipboardBitmap()</span><br><span class="line">        print(&quot;位图：&quot;, bmp)</span><br><span class="line">123456789</span><br></pre></td></tr></table></figure>

<p>不过更关键的是设置数据到剪切板。</p>
<p><strong>设置文本到剪切板：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto.SetClipboardText(&#x27;Hello World&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>设置富文本到剪切板：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto.SetClipboardHtml(&#x27;&lt;h1&gt;Title&lt;/h1&gt;&lt;br&gt;&lt;h3&gt;Hello&lt;/h3&gt;&lt;br&gt;&lt;p&gt;test html&lt;/p&gt;&lt;br&gt;&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>设置图片到剪切板</strong>，只需要将Bitmap设置到剪切板即可，下面演示通过图片文件路径构造Bitmap并设置到剪切板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with auto.Bitmap.FromFile(path) as bmp:</span><br><span class="line">    auto.SetClipboardBitmap(bmp)</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>而根据文件路径设置文件到剪切板已通过win32clipboard实现，详见：**<a target="_blank" rel="noopener" href="https://blog.csdn.net/as604049322/article/details/120631425">《UI自动化控制微信发送文件》</a>**一文。</p>
<h2 id="自带的Logger日志输出类"><a href="#自带的Logger日志输出类" class="headerlink" title="自带的Logger日志输出类"></a>自带的Logger日志输出类</h2><p>uiautomation自带了日志输出类，有时我们希望输出不仅到控制台，同时输出到文件时，可以直接使用uiautomation自带的方法。</p>
<p>基础输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">auto.Logger.Write(</span><br><span class="line">    log: Any,</span><br><span class="line">    consoleColor: int = -1,</span><br><span class="line">    writeToFile: bool = True,</span><br><span class="line">    printToStdout: bool = True,</span><br><span class="line">    logFile: str = None,</span><br><span class="line">    printTruncateLen: int = 0,</span><br><span class="line">)</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>

<ul>
<li></li>
<li><p>log: 要输出的日志内容</p>
</li>
<li></li>
<li><p>consoleColor: 文本在控制台输出的颜色</p>
</li>
<li></li>
<li><p>writeToFile: 是否输出到文件，默认为True</p>
</li>
<li></li>
<li><p>printToStdout: 是否输出到控制台，默认为True</p>
</li>
<li></li>
<li><p>logFile: 日志文件所在位置，默认为当前目录下的@AutomationLog.txt文件</p>
</li>
<li></li>
<li><p>printTruncateLen: 日志截断大小，每条输出超过长度限制时在控制台的输出会被截断。设置该值小于等于0时则不截断。</p>
</li>
<li></li>
</ul>
<p>对于第二个颜色参数，我们可以直接通过auto.ConsoleColor中的变量来获取对应常量，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto.Logger.Write(&#x27;测试输出&#x27;, auto.ConsoleColor.Yellow)</span><br></pre></td></tr></table></figure>

<p>可以看一下支持的颜色列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">colors = [color for color in dir(</span><br><span class="line">    auto.ConsoleColor) if not color.startswith(&quot;__&quot;)]</span><br><span class="line">print(colors)</span><br><span class="line">12</span><br><span class="line">[&#x27;Black&#x27;, &#x27;Blue&#x27;, &#x27;Cyan&#x27;, &#x27;DarkBlue&#x27;, &#x27;DarkCyan&#x27;, &#x27;DarkGray&#x27;, &#x27;DarkGreen&#x27;, &#x27;DarkMagenta&#x27;, &#x27;DarkRed&#x27;, &#x27;DarkYellow&#x27;, &#x27;Default&#x27;, &#x27;Gray&#x27;, &#x27;Green&#x27;, &#x27;Magenta&#x27;, &#x27;Red&#x27;, &#x27;White&#x27;, &#x27;Yellow&#x27;]</span><br></pre></td></tr></table></figure>

<p>auto.Logger.WriteLine函数与auto.Logger.Write几乎等价，只是少了printTruncateLen参数。</p>
<p>可以使用auto.Logger.ColorfullyWrite方法对指定部分的文本修改颜色：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto.Logger.ColorfullyWrite(&#x27;一段文本&lt;Color=Red&gt;红色&lt;/Color&gt;，黑色&lt;Color=Blue&gt;蓝色&lt;/Color&gt;结束&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_11.png?x-oss-process=style/watermark" alt="image-20211116230456997"></p>
<p>不过以上命令的颜色效果只在有标准控制台的窗口输出才有效。</p>
<h2 id="全局热键与多线程"><a href="#全局热键与多线程" class="headerlink" title="全局热键与多线程"></a>全局热键与多线程</h2><p>在常规的场景中，我们一般使用pynput实现全局热键的注册，但实际上pynput相对于uiautomation库的热键功能是比较难用。</p>
<p>在uiautomation注册全局热键非常简单，只需要调用auto.RunByHotKey传入快捷键和函数即可。下面演示一个简单的例子，按下快捷键分别打印文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">from threading import Event</span><br><span class="line"></span><br><span class="line">import uiautomation as auto</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def demo1(stopEvent: Event):</span><br><span class="line">    thread = threading.currentThread()</span><br><span class="line">    print(thread.name, thread.ident, &quot;demo1&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def demo2(stopEvent: Event):</span><br><span class="line">    thread = threading.currentThread()</span><br><span class="line">    print(thread.name, thread.ident, &quot;demo2&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def demo3(stopEvent: Event):</span><br><span class="line">    thread = threading.currentThread()</span><br><span class="line">    print(thread.name, thread.ident, &quot;demo3&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    thread = threading.currentThread()</span><br><span class="line">    print(thread.name, thread.ident, &quot;main&quot;)</span><br><span class="line">    auto.RunByHotKey(&#123;</span><br><span class="line">        (0, auto.Keys.VK_F2): demo1,</span><br><span class="line">        (auto.ModifierKey.Control, auto.Keys.VK_1): demo2,</span><br><span class="line">        (auto.ModifierKey.Control | auto.ModifierKey.Shift, auto.Keys.VK_2): demo3,</span><br><span class="line">    &#125;, waitHotKeyReleased=False)</span><br><span class="line">12345678910111213141516171819</span><br></pre></td></tr></table></figure>

<p>以上代码分别注册了快捷键F2，Ctrl+1和Ctrl+Shift+2。下面测试运行该程序并分别按下这三个快捷键，最后按下Ctrl+D结束程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MainThread 4404 main</span><br><span class="line">Register hotkey (&#x27;&#x27;, &#x27;VK_F2&#x27;) successfully</span><br><span class="line">Register hotkey (&#x27;Control&#x27;, &#x27;VK_1&#x27;) successfully</span><br><span class="line">Register hotkey (&#x27;Control|Shift&#x27;, &#x27;VK_2&#x27;) successfully</span><br><span class="line">Register exit hotkey (&#x27;Control&#x27;, &#x27;VK_D&#x27;) successfully</span><br><span class="line">----------hotkey (&#x27;&#x27;, &#x27;VK_F2&#x27;) pressed----------</span><br><span class="line">Thread-1 4608 demo1</span><br><span class="line">&lt;Thread(Thread-1, started 4608)&gt; for function demo1 exits, hotkey (&#x27;&#x27;, &#x27;VK_F2&#x27;)</span><br><span class="line">----------hotkey (&#x27;Control&#x27;, &#x27;VK_1&#x27;) pressed----------</span><br><span class="line">Thread-2 12468 demo2</span><br><span class="line">&lt;Thread(Thread-2, started 12468)&gt; for function demo2 exits, hotkey (&#x27;Control&#x27;, &#x27;VK_1&#x27;)</span><br><span class="line">----------hotkey (&#x27;Control|Shift&#x27;, &#x27;VK_2&#x27;) pressed----------</span><br><span class="line">Thread-3 5428 demo3</span><br><span class="line">&lt;Thread(Thread-3, started 5428)&gt; for function demo3 exits, hotkey (&#x27;Control|Shift&#x27;, &#x27;VK_2&#x27;)</span><br><span class="line">Exit hotkey pressed. Exit</span><br><span class="line">1234567891011121314</span><br></pre></td></tr></table></figure>

<p>由于每次按下热键都会启动独立的线程执行该函数，从打印日志可以看到每次按下执行函数的线程都不同。</p>
<p>RunByHotKey的参数列表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RunByHotKey(keyFunctions: Dict[Tuple[int, int], (...) -&gt; Any],</span><br><span class="line">                stopHotKey: Optional[Tuple[int, int]] = None,</span><br><span class="line">                exitHotKey: Tuple[int, int] = (ModifierKey.Control, Keys.VK_D),</span><br><span class="line">                waitHotKeyReleased: bool = True)</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>其中exitHotKey表示程序退出的快捷键，默认为Ctrl+D。waitHotKeyReleased表示是否等待弹起后执行，经测试设置为False不等待更佳。</p>
<p>stopHotKey表示产生退出事件的快捷键，当我们设置该参数并在运行中按下该快捷键，函数的参数stopEvent将会被设置，调用.is_set()将会返回True。</p>
<p>我们可以在热键需要执行一个耗时较长的循环操作时，在循环中判断该事件是否被设置，设置就退出循环。</p>
<p>演示一个简单的示例，按下Ctrl+S启动热键，每0.5秒打印一个数字直到10，按下Ctrl+E则中断热键执行。重新按下Ctrl+S还可以继续：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">from threading import Event</span><br><span class="line"></span><br><span class="line">import uiautomation as auto</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def demo1(stopEvent: Event):</span><br><span class="line">    for i in range(10):</span><br><span class="line">        if stopEvent.is_set():</span><br><span class="line">            print(&quot;退出循环&quot;)</span><br><span class="line">            break</span><br><span class="line">        print(i, end=&quot; &quot;)</span><br><span class="line">        stopEvent.wait(0.5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    thread = threading.currentThread()</span><br><span class="line">    print(thread.name, thread.ident, &quot;main&quot;)</span><br><span class="line">    auto.RunByHotKey(&#123;</span><br><span class="line">        (0, auto.Keys.VK_S): demo1,</span><br><span class="line">    &#125;, stopHotKey=(0, auto.Keys.VK_E),</span><br><span class="line">        waitHotKeyReleased=True)</span><br><span class="line">12345678910111213141516</span><br></pre></td></tr></table></figure>

<p>测试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Register hotkey (&#x27;Control&#x27;, &#x27;VK_S&#x27;) successfully</span><br><span class="line">Register stop hotkey (&#x27;Control&#x27;, &#x27;VK_E&#x27;) successfully</span><br><span class="line">Register exit hotkey (&#x27;Control&#x27;, &#x27;VK_D&#x27;) successfully</span><br><span class="line">----------hotkey (&#x27;Control&#x27;, &#x27;VK_S&#x27;) pressed----------</span><br><span class="line">0 1 2 3 4 ----------stop hotkey pressed----------</span><br><span class="line">退出热键被按下，结束！</span><br><span class="line">&lt;Thread(Thread-1, started 10016)&gt; for function demo1 exits, hotkey (&#x27;Control&#x27;, &#x27;VK_S&#x27;)</span><br><span class="line">Exit hotkey pressed. Exit</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>

<p>需要注意在线程中需要使用控件对象相关方法时，要在新线程中进行相应的初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto.InitializeUIAutomationInCurrentThread()</span><br><span class="line">...</span><br><span class="line">auto.UninitializeUIAutomationInCurrentThread()</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>也可以使用with语句简化代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with auto.UIAutomationInitializerInThread():</span><br><span class="line">    pass</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>…和pass替换为线程中实际操作的代码。</p>
<blockquote>
<p>⚠️：否则部分场景下会报错。</p>
</blockquote>
<h2 id="管理员提权"><a href="#管理员提权" class="headerlink" title="管理员提权"></a>管理员提权</h2><p>模板代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    if auto.IsUserAnAdmin():</span><br><span class="line">        main()</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;RunScriptAsAdmin&#x27;, sys.executable, sys.argv)</span><br><span class="line">        auto.RunScriptAsAdmin(sys.argv)</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>将原本存在于__main__代码块中的内容存放于main()方法中即可。</p>
<h1 id="通过实例学习UI自动化"><a href="#通过实例学习UI自动化" class="headerlink" title="通过实例学习UI自动化"></a>通过实例学习UI自动化</h1><h2 id="控制win10计算器自动计算"><a href="#控制win10计算器自动计算" class="headerlink" title="控制win10计算器自动计算"></a>控制win10计算器自动计算</h2><p>自动控制计算器更简单的方法是复制粘贴需要计算的字符串到计算器，但本节的目的为了演示点击按钮计算的效果。</p>
<p>首先启动计算器并设置窗口置顶：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import uiautomation as auto</span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line"># 显示搜索控件所遍历的控件数和搜索时间</span><br><span class="line">auto.uiautomation.DEBUG_SEARCH_TIME = True</span><br><span class="line"># 设置全局搜索超时时间为1秒</span><br><span class="line">auto.uiautomation.SetGlobalSearchTimeout(1)</span><br><span class="line"># 创建计算器窗口控件</span><br><span class="line">calcWindow = auto.WindowControl(</span><br><span class="line">    searchDepth=1, ClassName=&#x27;ApplicationFrameWindow&#x27;, Compare = lambda c,d : c.Name == &#x27;Calculator&#x27; or c.Name == &#x27;计算器&#x27;, desc=&#x27;计算器窗口&#x27;)</span><br><span class="line">if not calcWindow.Exists(0, 0):</span><br><span class="line">    subprocess.Popen(&#x27;calc&#x27;)</span><br><span class="line"># 设置窗口前置</span><br><span class="line">calcWindow.SetTopmost(True)</span><br><span class="line">123456789101112131415</span><br><span class="line">2021-09-21 23:10:34.990 &lt;ipython-input-5-ff74c0c97515&gt;[17] &lt;module&gt; -&gt; &#123;ClassName: &#x27;ApplicationFrameWindow&#x27;, desc: &#x27;计算器窗口&#x27;, ControlType: WindowControl&#125; TraverseControls: 2, SearchTime: 1.004s[23:10:33.984967 - 23:10:34.990062]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⚠️ Compare参数可以传入自定义搜索函数，两个参数分别为控件对象和搜索深度。上述代码能够适配Name属性可能为中文或英文的情况。 不过ClassName参数足够定位到计算器窗口，Compare参数可以直接删除。 Desc是无效的属性，可以在debug日志中打印出来，当然任何无效属性都可以在debug日志中打印出来。 calcWindow.Exists(0, 0)判断了计算器窗口是否已经存在，防止重复打开新的窗口。</p>
</blockquote>
<p>切换到科学计算器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 调低waitTime可以加快点击速度</span><br><span class="line">calcWindow.ButtonControl(AutomationId=&#x27;TogglePaneButton&#x27;,</span><br><span class="line">                         desc=&#x27;打开导航&#x27;).Click(waitTime=0.01)</span><br><span class="line">calcWindow.ListItemControl(AutomationId=&#x27;Scientific&#x27;,</span><br><span class="line">                           desc=&#x27;选择科学计算器&#x27;).Click(waitTime=0.01)</span><br><span class="line">clearButton = calcWindow.ButtonControl(AutomationId=&#x27;clearEntryButton&#x27;,</span><br><span class="line">                                       desc=&#x27;点击CE清空所有输入&#x27;)</span><br><span class="line">if clearButton.Exists(0, 0):</span><br><span class="line">    clearButton.Click(waitTime=0)</span><br><span class="line">else:</span><br><span class="line">    calcWindow.ButtonControl(AutomationId=&#x27;clearButton&#x27;,</span><br><span class="line">                             desc=&#x27;点击C清空所有输入&#x27;).Click(waitTime=0)</span><br><span class="line">1234567891011</span><br><span class="line">2021-09-21 23:22:28.966 &lt;ipython-input-10-a63d4ee11410&gt;[3] &lt;module&gt; -&gt; &#123;AutomationId: &#x27;TogglePaneButton&#x27;, desc: &#x27;打开导航&#x27;, ControlType: ButtonControl&#125; TraverseControls: 121, SearchTime: 0.061s[23:22:28.906224 - 23:22:28.966385]</span><br><span class="line">2021-09-21 23:22:29.518 &lt;ipython-input-10-a63d4ee11410&gt;[5] &lt;module&gt; -&gt; &#123;AutomationId: &#x27;Scientific&#x27;, desc: &#x27;选择科学计算器&#x27;, ControlType: ListItemControl&#125; TraverseControls: 133, SearchTime: 0.077s[23:22:29.442885 - 23:22:29.518933]</span><br><span class="line">2021-09-21 23:22:29.876 &lt;ipython-input-10-a63d4ee11410&gt;[12] &lt;module&gt; -&gt; &#123;AutomationId: &#x27;clearButton&#x27;, desc: &#x27;点击C清空所有输入&#x27;, ControlType: ButtonControl&#125; TraverseControls: 51, SearchTime: 0.029s[23:22:29.846955 - 23:22:29.876364]</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⚠️清空按钮在输入框有数和没有数时，按钮的标题和AutomationId不一样，所以先判断其中一种情况的按钮是否存在，不存在则切换到另一种形式的按钮进行点击。</p>
</blockquote>
<p>其中按钮的AutomationId属性可以通过inspect.exe工具或automation.py脚本获取。</p>
<p>下面只演示四则运算，先通过inspect.exe工具获取每个按钮控件对应的AutomationId：</p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_12.png?x-oss-process=style/watermark" alt="image-20210921235027029"></p>
<p>然后通过auto.WalkControl遍历所有控件，从而缓存每个字符对应的按钮控件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">id2char = &#123;</span><br><span class="line">    &#x27;num0Button&#x27;: &#x27;0&#x27;,</span><br><span class="line">    &#x27;num1Button&#x27;: &#x27;1&#x27;,</span><br><span class="line">    &#x27;num2Button&#x27;: &#x27;2&#x27;,</span><br><span class="line">    &#x27;num3Button&#x27;: &#x27;3&#x27;,</span><br><span class="line">    &#x27;num4Button&#x27;: &#x27;4&#x27;,</span><br><span class="line">    &#x27;num5Button&#x27;: &#x27;5&#x27;,</span><br><span class="line">    &#x27;num6Button&#x27;: &#x27;6&#x27;,</span><br><span class="line">    &#x27;num7Button&#x27;: &#x27;7&#x27;,</span><br><span class="line">    &#x27;num8Button&#x27;: &#x27;8&#x27;,</span><br><span class="line">    &#x27;num9Button&#x27;: &#x27;9&#x27;,</span><br><span class="line">    &#x27;decimalSeparatorButton&#x27;: &#x27;.&#x27;,</span><br><span class="line">    &#x27;plusButton&#x27;: &#x27;+&#x27;,</span><br><span class="line">    &#x27;minusButton&#x27;: &#x27;-&#x27;,</span><br><span class="line">    &#x27;multiplyButton&#x27;: &#x27;*&#x27;,</span><br><span class="line">    &#x27;divideButton&#x27;: &#x27;/&#x27;,</span><br><span class="line">    &#x27;equalButton&#x27;: &#x27;=&#x27;,</span><br><span class="line">    &#x27;openParenthesisButton&#x27;: &#x27;(&#x27;,</span><br><span class="line">    &#x27;closeParenthesisButton&#x27;: &#x27;)&#x27;</span><br><span class="line">&#125;</span><br><span class="line">char2Button = &#123;&#125;</span><br><span class="line">for c, d in auto.WalkControl(calcWindow, maxDepth=4):</span><br><span class="line">    if c.AutomationId in id2char:</span><br><span class="line">        char2Button[id2char[c.AutomationId]] = c</span><br><span class="line">1234567891011121314151617181920212223</span><br></pre></td></tr></table></figure>

<p>然后封装一下对四则运算表达式计算的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def calc(expression):</span><br><span class="line">    expression = &#x27;&#x27;.join(expression.split())</span><br><span class="line">    if not expression.endswith(&#x27;=&#x27;):</span><br><span class="line">        expression += &#x27;=&#x27;</span><br><span class="line">    for char in expression:</span><br><span class="line">        char2Button[char].Click(waitTime=0)</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line">    calcWindow.SendKeys(&#x27;&#123;Ctrl&#125;c&#x27;, waitTime=0.1)</span><br><span class="line">    return auto.GetClipboardText()</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>

<p>测试一个四则表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calc(&#x27;1234 * (4 + 5 + 6) - 78 / 90.8&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_13.gif" alt="img"></p>
<p>需要截屏的话可以调用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calcWindow.CaptureToImage(&#x27;calc.png&#x27;, x=7, y=0, width=-14, height=-7)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⚠️x和y表示起始坐标，由于win10的计算器存在7像素的阴影，所以可以去掉。 width和height为负数时，表示原宽度减少指定值。垂直方向上只有下方有阴影，水平方向上左右均有阴影。</p>
</blockquote>
<p>关闭程序只需调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calcWindow.GetWindowPattern().Close()</span><br></pre></td></tr></table></figure>

<p><strong>完整代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">import uiautomation as auto</span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line"># 显示搜索控件所遍历的控件数和搜索时间</span><br><span class="line">auto.uiautomation.DEBUG_SEARCH_TIME = True</span><br><span class="line"># 设置全局搜索超时时间为1秒</span><br><span class="line">auto.uiautomation.SetGlobalSearchTimeout(1)</span><br><span class="line"># 创建计算器窗口控件</span><br><span class="line">calcWindow = auto.WindowControl(</span><br><span class="line">    searchDepth=1, ClassName=&#x27;ApplicationFrameWindow&#x27;, desc=&#x27;计算器窗口&#x27;)</span><br><span class="line">if not calcWindow.Exists(0, 0):</span><br><span class="line">    subprocess.Popen(&#x27;calc&#x27;)</span><br><span class="line"># 设置窗口前置</span><br><span class="line">calcWindow.SetTopmost(True)</span><br><span class="line"># 调低waitTime可以加快点击速度</span><br><span class="line">calcWindow.ButtonControl(AutomationId=&#x27;TogglePaneButton&#x27;,</span><br><span class="line">                         desc=&#x27;打开导航&#x27;).Click(waitTime=0.01)</span><br><span class="line">calcWindow.ListItemControl(AutomationId=&#x27;Scientific&#x27;,</span><br><span class="line">                           desc=&#x27;选择科学计算器&#x27;).Click(waitTime=0.01)</span><br><span class="line">clearButton = calcWindow.ButtonControl(AutomationId=&#x27;clearEntryButton&#x27;,</span><br><span class="line">                                       desc=&#x27;点击CE清空所有输入&#x27;)</span><br><span class="line">if clearButton.Exists(0, 0):</span><br><span class="line">    clearButton.Click(waitTime=0)</span><br><span class="line">else:</span><br><span class="line">    calcWindow.ButtonControl(AutomationId=&#x27;clearButton&#x27;,</span><br><span class="line">                             desc=&#x27;点击C清空所有输入&#x27;).Click(waitTime=0)</span><br><span class="line">id2char = &#123;</span><br><span class="line">    &#x27;num0Button&#x27;: &#x27;0&#x27;,</span><br><span class="line">    &#x27;num1Button&#x27;: &#x27;1&#x27;,</span><br><span class="line">    &#x27;num2Button&#x27;: &#x27;2&#x27;,</span><br><span class="line">    &#x27;num3Button&#x27;: &#x27;3&#x27;,</span><br><span class="line">    &#x27;num4Button&#x27;: &#x27;4&#x27;,</span><br><span class="line">    &#x27;num5Button&#x27;: &#x27;5&#x27;,</span><br><span class="line">    &#x27;num6Button&#x27;: &#x27;6&#x27;,</span><br><span class="line">    &#x27;num7Button&#x27;: &#x27;7&#x27;,</span><br><span class="line">    &#x27;num8Button&#x27;: &#x27;8&#x27;,</span><br><span class="line">    &#x27;num9Button&#x27;: &#x27;9&#x27;,</span><br><span class="line">    &#x27;decimalSeparatorButton&#x27;: &#x27;.&#x27;,</span><br><span class="line">    &#x27;plusButton&#x27;: &#x27;+&#x27;,</span><br><span class="line">    &#x27;minusButton&#x27;: &#x27;-&#x27;,</span><br><span class="line">    &#x27;multiplyButton&#x27;: &#x27;*&#x27;,</span><br><span class="line">    &#x27;divideButton&#x27;: &#x27;/&#x27;,</span><br><span class="line">    &#x27;equalButton&#x27;: &#x27;=&#x27;,</span><br><span class="line">    &#x27;openParenthesisButton&#x27;: &#x27;(&#x27;,</span><br><span class="line">    &#x27;closeParenthesisButton&#x27;: &#x27;)&#x27;</span><br><span class="line">&#125;</span><br><span class="line">char2Button = &#123;&#125;</span><br><span class="line">for c, d in auto.WalkControl(calcWindow, maxDepth=4):</span><br><span class="line">    if c.AutomationId in id2char:</span><br><span class="line">        char2Button[id2char[c.AutomationId]] = c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def calc(expression):</span><br><span class="line">    expression = &#x27;&#x27;.join(expression.split())</span><br><span class="line">    if not expression.endswith(&#x27;=&#x27;):</span><br><span class="line">        expression += &#x27;=&#x27;</span><br><span class="line">    for char in expression:</span><br><span class="line">        char2Button[char].Click(waitTime=0)</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line">    calcWindow.SendKeys(&#x27;&#123;Ctrl&#125;c&#x27;, waitTime=0.1)</span><br><span class="line">    return auto.GetClipboardText()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = calc(&#x27;1234 * (4 + 5 + 6) - 78 / 90.8&#x27;)</span><br><span class="line">print(&#x27;1234 * (4 + 5 + 6) - 78 / 90.8 =&#x27;, result)</span><br><span class="line">result = calc(&#x27;3*3+4*4&#x27;)</span><br><span class="line">print(&#x27;3*3+4*4 =&#x27;, result)</span><br><span class="line">result = calc(&#x27;2*3.14159*10&#x27;)</span><br><span class="line">print(&#x27;2*3.14159*10 =&#x27;, result)</span><br><span class="line">calcWindow.CaptureToImage(&#x27;calc.png&#x27;, x=7, y=0, width=-14, height=-7)</span><br><span class="line">calcWindow.GetWindowPattern().Close()</span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1234 * (4 + 5 + 6) - 78 / 90.8 = 18509.140969162995594713656387665</span><br><span class="line">3*3+4*4 = 25</span><br><span class="line">2*3.14159*10 = 62.8318</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>产生的截图：</p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_14.png?x-oss-process=style/watermark" alt="image-20211111210023786"></p>
<p>运行过程中的原速动图：</p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_15.gif" alt="请添加图片描述"></p>
<h2 id="窗口的拖拽与缩放"><a href="#窗口的拖拽与缩放" class="headerlink" title="窗口的拖拽与缩放"></a>窗口的拖拽与缩放</h2><p>下面我们使用一个记事本窗口作为前置窗口就行演示，首先打开记事本窗口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">import uiautomation as auto</span><br><span class="line"># 设置全局搜索超时时间为1秒</span><br><span class="line">auto.uiautomation.SetGlobalSearchTimeout(1)</span><br><span class="line"></span><br><span class="line">note = auto.WindowControl(searchDepth=1, ClassName=&#x27;Notepad&#x27;)</span><br><span class="line">if not note.Exists(0, 0):</span><br><span class="line">    subprocess.Popen(&#x27;notepad.exe&#x27;)</span><br><span class="line">note.SetActive()</span><br><span class="line">note.SetTopmost(waitTime=0)</span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure>

<p>调整窗口位置和大小后，输入文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 移动窗口的位置，前两个参数表示左上角的位置，后两个参数编程窗口大小</span><br><span class="line">note.MoveWindow(300, 70, 480, 400)</span><br><span class="line">edit = note.EditControl()</span><br><span class="line">edit.SendKeys(&#x27;&#123;Ctrl&#125;&#123;End&#125;&#123;Enter 2&#125;我是置顶窗口!!!\n我将遮住其他窗口.&#x27;)</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>打开计算器窗口并调整：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 打开计算器窗口并调整：</span><br><span class="line">calcWindow = auto.WindowControl(</span><br><span class="line">    searchDepth=1, ClassName=&#x27;ApplicationFrameWindow&#x27;)</span><br><span class="line">if not calcWindow.Exists(0, 0):</span><br><span class="line">    subprocess.Popen(&#x27;calc&#x27;)</span><br><span class="line">calcWindow.SetActive()</span><br><span class="line">calcWindow.MoveWindow(100, 100, 320, 500)</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_16.png?x-oss-process=style/watermark" alt="image-20211112202543934"></p>
<p>再进行本例最精彩的部分，以拖拽方式移动窗口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 鼠标从位置(240, 110)拖拽到(840, 110)</span><br><span class="line">auto.DragDrop(240, 110, 840, 110, waitTime=0.1)</span><br><span class="line"># 再拖拽回去</span><br><span class="line">auto.DragDrop(840, 110, 240, 110, waitTime=0.1)</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>最后打印文本并关闭窗口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">calcWindow.GetWindowPattern().Close()</span><br><span class="line">edit.SendKeys(&#x27;&#123;Ctrl&#125;&#123;End&#125;&#123;Enter 2&#125;关闭计算器窗口&#x27;)</span><br><span class="line">vp = edit.GetValuePattern()</span><br><span class="line">print(&#x27;当前文本:&#x27;, vp.Value)</span><br><span class="line"># 激活记事本窗口</span><br><span class="line">note.SetActive()</span><br><span class="line">note.GetWindowPattern().Close()</span><br><span class="line"># 确认不保存</span><br><span class="line">auto.SendKeys(&#x27;&#123;ALT&#125;n&#x27;)</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>

<p><strong>完整代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">import uiautomation as auto</span><br><span class="line"># 设置全局搜索超时时间为1秒</span><br><span class="line">auto.uiautomation.SetGlobalSearchTimeout(1)</span><br><span class="line"></span><br><span class="line">note = auto.WindowControl(searchDepth=1, ClassName=&#x27;Notepad&#x27;)</span><br><span class="line">if not note.Exists(0, 0):</span><br><span class="line">    subprocess.Popen(&#x27;notepad.exe&#x27;)</span><br><span class="line">note.SetActive()</span><br><span class="line">note.SetTopmost(waitTime=0)</span><br><span class="line"></span><br><span class="line"># 移动窗口的位置，前两个参数表示左上角的位置，后两个参数编程窗口大小</span><br><span class="line">note.MoveWindow(300, 70, 480, 400)</span><br><span class="line">edit = note.EditControl()</span><br><span class="line">edit.SendKeys(&#x27;&#123;Ctrl&#125;&#123;End&#125;&#123;Enter 2&#125;我是置顶窗口!!!\n我将遮住其他窗口.&#x27;)</span><br><span class="line"># 打开计算器窗口并调整：</span><br><span class="line">calcWindow = auto.WindowControl(</span><br><span class="line">    searchDepth=1, ClassName=&#x27;ApplicationFrameWindow&#x27;)</span><br><span class="line">if not calcWindow.Exists(0, 0):</span><br><span class="line">    subprocess.Popen(&#x27;calc&#x27;)</span><br><span class="line">calcWindow.SetActive()</span><br><span class="line">calcWindow.MoveWindow(100, 100, 320, 500)</span><br><span class="line"># 鼠标从位置(240, 110)拖拽到(840, 110)</span><br><span class="line">auto.DragDrop(240, 110, 840, 110, waitTime=0.1)</span><br><span class="line"># 再拖拽回去</span><br><span class="line">auto.DragDrop(840, 110, 240, 110, waitTime=0.1)</span><br><span class="line"># 打印文本并关闭窗口：</span><br><span class="line">calcWindow.GetWindowPattern().Close()</span><br><span class="line">edit.SendKeys(&#x27;&#123;Ctrl&#125;&#123;End&#125;&#123;Enter 2&#125;关闭计算器窗口&#x27;)</span><br><span class="line">vp = edit.GetValuePattern()</span><br><span class="line">print(&#x27;当前文本:&#x27;, vp.Value)</span><br><span class="line"># 激活记事本窗口</span><br><span class="line">note.SetActive()</span><br><span class="line">note.GetWindowPattern().Close()</span><br><span class="line"># 确认不保存</span><br><span class="line">auto.SendKeys(&#x27;&#123;ALT&#125;n&#x27;)</span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435</span><br></pre></td></tr></table></figure>

<p>运行效果(图片使用了全局色键压缩，导致颜色失真)：</p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_17.gif" alt="请添加图片描述"></p>
<h2 id="管理员提权操作并读取设备管理器栏目数据"><a href="#管理员提权操作并读取设备管理器栏目数据" class="headerlink" title="管理员提权操作并读取设备管理器栏目数据"></a>管理员提权操作并读取设备管理器栏目数据</h2><p>由于必须要有管理员权限才能读取设备管理器，在没有管理员权限的控制台需要进行管理员身份提权。本案例涉及很多小知识点，下面先拆分来单独列出来。</p>
<p><strong>获取屏幕大小：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto.GetScreenSize()</span><br><span class="line">(1920, 1080)</span><br></pre></td></tr></table></figure>

<p>获取当前运行的程序的控制台并移动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sw, sh = auto.GetScreenSize()</span><br><span class="line">cmdWindow = auto.GetConsoleWindow()</span><br><span class="line">if cmdWindow:</span><br><span class="line">    cmdTransformPattern = cmdWindow.GetTransformPattern()</span><br><span class="line">    cmdTransformPattern.Move(sw // 2, 0)</span><br><span class="line">    cmdTransformPattern.Resize(sw // 2, sh * 3 // 4)</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>打开设置管理器并修改窗口大小和位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">subprocess.Popen(&#x27;mmc.exe devmgmt.msc&#x27;)</span><br><span class="line">mmcWindow = auto.WindowControl(searchDepth = 1, ClassName = &#x27;MMCMainFrame&#x27;)</span><br><span class="line">mmcTransformPattern = mmcWindow.GetTransformPattern()</span><br><span class="line">mmcTransformPattern.Move(0, 0)</span><br><span class="line">mmcTransformPattern.Resize(sw // 2, sh * 3 // 4)</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>下面我们的目标是提取出设备管理器的每一项的信息：</p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_18.png?x-oss-process=style/watermark" alt="image-20211112221747877"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tree = mmcWindow.TreeControl()</span><br><span class="line">for item, depth in auto.WalkControl(tree, includeTop=False):</span><br><span class="line">    if not isinstance(item, auto.TreeItemControl):</span><br><span class="line">        continue</span><br><span class="line">    item.GetSelectionItemPattern().Select(waitTime=0.01)</span><br><span class="line">    pattern = item.GetExpandCollapsePattern()</span><br><span class="line">    if pattern.ExpandCollapseState == auto.ExpandCollapseState.Collapsed:</span><br><span class="line">        pattern.Expand(waitTime=0.01)</span><br><span class="line">    print(&#x27; &#x27; * (depth - 1) * 4, item.Name)</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>

<p>部分结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DESKTOP-IS8QJHF</span><br><span class="line">     IDE ATA/ATAPI 控制器</span><br><span class="line">         Intel(R) 300 Series Chipset Family SATA AHCI Controller</span><br><span class="line">     便携设备</span><br><span class="line">         Seagate1.81TB</span><br><span class="line">     .....</span><br><span class="line">     音频输入和输出</span><br><span class="line">         24B1W1G5 (英特尔(R) 显示器音频)</span><br><span class="line">         Realtek Digital Output (Realtek High Definition Audio)</span><br><span class="line">         立体声混音 (Realtek High Definition Audio)</span><br><span class="line">         扬声器 (Realtek High Definition Audio)</span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure>

<p>上述代码执行后，滚动条已经到底底部，下面我们可以执行以下代码让滚动条回到顶部：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">treeScrollPattern = tree.GetScrollPattern()</span><br><span class="line">treeScrollPattern.SetScrollPercent(-1, 0)</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>SetScrollPercent传入的两个参数表示将滚动条移动到指定百分比位置：</p>
<ul>
<li></li>
<li><p><strong>horizontalPercent</strong>: 横向位置百分比</p>
</li>
<li></li>
<li><p><strong>verticalPercent</strong>: 纵向位置百分比</p>
</li>
<li></li>
</ul>
<p>传入-1表示不移动，由于没有横向滚动条，所以第一个参数传入了-1。</p>
<p>当然也可以移动到底部：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">treeScrollPattern.SetScrollPercent(-1, 100)</span><br></pre></td></tr></table></figure>

<p>也可以使用鼠标滑轮实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 滚动条未到顶就使鼠标滑轮不停往上滑</span><br><span class="line">while treeScrollPattern.VerticalScrollPercent &gt; 0:</span><br><span class="line">    tree.WheelUp(waitTime=0.01)</span><br><span class="line"># 滚动条未到底就使鼠标滑轮不停往下滑</span><br><span class="line">while treeScrollPattern.VerticalScrollPercent &lt; 100:</span><br><span class="line">    tree.WheelDown(waitTime=0.01)</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>上述两个操作也可以直接通过快捷键实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tree.SendKeys(&#x27;&#123;Ctrl&#125;&#123;Home&#125;&#x27;, waitTime = 1)</span><br><span class="line">tree.SendKeys(&#x27;&#123;Ctrl&#125;&#123;End&#125;&#x27;, waitTime = 1)</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>前面我们在获取tree控件时，设备管理器并没有滚动条，展开控件后产生的滚动条。此时必须更新控件信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(tree.NativeWindowHandle, tree.Element, len(tree.GetChildren()))</span><br><span class="line">tree.Refind()</span><br><span class="line">print(tree.NativeWindowHandle, tree.Element, len(tree.GetChildren()))</span><br><span class="line">12</span><br><span class="line">329304 &lt;POINTER(IUIAutomationElement) ptr=0x1df11091f00 at 1df1c7d14c8&gt; 1</span><br><span class="line">329304 &lt;POINTER(IUIAutomationElement) ptr=0x1df11092480 at 1df1d889148&gt; 2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>可以看到再重新查找控件后，控件信息发生变化。</p>
<p>下面我们直接拖拽滚动条来实现界面区域的变化，我们需要先知道windows的滚动条组件由三个按钮和一个缩略图组成，首先我们获取滚动条和其中的滑动块对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vScrollBar = tree.ScrollBarControl(AutomationId=&#x27;NonClientVerticalScrollBar&#x27;)</span><br><span class="line">thumb = vScrollBar.ThumbControl()</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>然后移动鼠标到滑动块中心位置并获取位置坐标：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x, y = thumb.MoveCursorToMyCenter()</span><br><span class="line">print(x, y)</span><br><span class="line">1</span><br><span class="line">941 663</span><br></pre></td></tr></table></figure>

<p>获取整个滚动条的坐标范围：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vScrollBarRect = vScrollBar.BoundingRectangle</span><br><span class="line">print(vScrollBarRect, vScrollBarRect.top, vScrollBarRect.bottom)</span><br><span class="line">1</span><br><span class="line">(933,86,950,778)[17x692] 86 778</span><br></pre></td></tr></table></figure>

<p>鼠标拖拽滑动条从底到顶：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vScrollBar = tree.ScrollBarControl(AutomationId=&#x27;NonClientVerticalScrollBar&#x27;)</span><br><span class="line">thumb = vScrollBar.ThumbControl()</span><br><span class="line">x, y = thumb.MoveCursorToMyCenter()</span><br><span class="line">vScrollBarRect = vScrollBar.BoundingRectangle</span><br><span class="line">auto.DragDrop(x, y, x, vScrollBarRect.top, waitTime=1)</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>从顶到底：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x, y = thumb.MoveCursorToMyCenter()</span><br><span class="line">auto.DragDrop(x, y, x, vScrollBarRect.bottom, waitTime=1)</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>下面我们将上述方法整理到一个脚本中，假如我们需要管理员提权可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto.RunScriptAsAdmin(sys.argv)</span><br></pre></td></tr></table></figure>

<p>实际使用过程中需要使用如下命令判断是否已经具备管理员避免无限循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto.IsUserAnAdmin()</span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">小小明的代码</span><br><span class="line">CSDN主页：https://blog.csdn.net/as604049322</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">__author__ = &#x27;小小明&#x27;</span><br><span class="line">__time__ = &#x27;2021/11/12&#x27;</span><br><span class="line"></span><br><span class="line">import subprocess</span><br><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">import uiautomation as auto</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    sw, sh = auto.GetScreenSize()</span><br><span class="line">    cmdWindow = auto.GetConsoleWindow()</span><br><span class="line">    if cmdWindow:</span><br><span class="line">        cmdTransformPattern = cmdWindow.GetTransformPattern()</span><br><span class="line">        cmdTransformPattern.Move(sw // 4, 0)</span><br><span class="line">        cmdTransformPattern.Resize(sw // 4, sh * 3 // 5)</span><br><span class="line"></span><br><span class="line">    subprocess.Popen(&#x27;mmc.exe devmgmt.msc&#x27;)</span><br><span class="line">    mmcWindow = auto.WindowControl(searchDepth=1, ClassName=&#x27;MMCMainFrame&#x27;)</span><br><span class="line">    mmcTransformPattern = mmcWindow.GetTransformPattern()</span><br><span class="line">    mmcTransformPattern.Move(0, 0)</span><br><span class="line">    mmcTransformPattern.Resize(sw // 4, sh * 3 // 5)</span><br><span class="line"></span><br><span class="line">    tree = mmcWindow.TreeControl()</span><br><span class="line">    for item, depth in auto.WalkControl(tree, includeTop=False):</span><br><span class="line">        if not isinstance(item, auto.TreeItemControl):</span><br><span class="line">            continue</span><br><span class="line">        item.GetSelectionItemPattern().Select(waitTime=0.01)</span><br><span class="line">        pattern = item.GetExpandCollapsePattern()</span><br><span class="line">        if pattern.ExpandCollapseState == auto.ExpandCollapseState.Collapsed:</span><br><span class="line">            pattern.Expand(waitTime=0.01)</span><br><span class="line">        print(&#x27; &#x27; * (depth - 1) * 4, item.Name)</span><br><span class="line"></span><br><span class="line">    tree = mmcWindow.TreeControl()</span><br><span class="line">    treeScrollPattern = tree.GetScrollPattern()</span><br><span class="line">    print(&quot;ScrollPattern.SetScrollPercent(1, 0)&quot;)</span><br><span class="line">    treeScrollPattern.SetScrollPercent(1, 0)</span><br><span class="line">    print(&quot;ScrollPattern.SetScrollPercent(1, 100)&quot;)</span><br><span class="line">    treeScrollPattern.SetScrollPercent(1, 100)</span><br><span class="line"></span><br><span class="line">    treeScrollPattern = tree.GetScrollPattern()</span><br><span class="line">    print(&quot;滚动条未到顶就使鼠标滑轮不停往上滑&quot;)</span><br><span class="line">    # 滚动条未到顶就使鼠标滑轮不停往上滑</span><br><span class="line">    while treeScrollPattern.VerticalScrollPercent &gt; 0:</span><br><span class="line">        tree.WheelUp(waitTime=0.01)</span><br><span class="line">    print(&quot;滚动条未到底就使鼠标滑轮不停往下滑&quot;)</span><br><span class="line">    # 滚动条未到底就使鼠标滑轮不停往下滑</span><br><span class="line">    while treeScrollPattern.VerticalScrollPercent &lt; 100:</span><br><span class="line">        tree.WheelDown(waitTime=0.01)</span><br><span class="line">    print(&quot;快捷键控制窗口滚动到顶&quot;)</span><br><span class="line">    tree.SendKeys(&#x27;&#123;Ctrl&#125;&#123;Home&#125;&#x27;, waitTime=1)</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print(&quot;快捷键控制窗口滚动到底&quot;)</span><br><span class="line">    tree.SendKeys(&#x27;&#123;Ctrl&#125;&#123;End&#125;&#x27;, waitTime=1)</span><br><span class="line"></span><br><span class="line">    tree.Refind()</span><br><span class="line"></span><br><span class="line">    vScrollBar = tree.ScrollBarControl(AutomationId=&#x27;NonClientVerticalScrollBar&#x27;)</span><br><span class="line">    thumb = vScrollBar.ThumbControl()</span><br><span class="line">    vScrollBarRect = vScrollBar.BoundingRectangle</span><br><span class="line">    x, y = thumb.MoveCursorToMyCenter()</span><br><span class="line">    print(&quot;拖拽滚动条向上移动...&quot;)</span><br><span class="line">    auto.DragDrop(x, y, x, vScrollBarRect.top, waitTime=1)</span><br><span class="line">    x, y = thumb.MoveCursorToMyCenter()</span><br><span class="line">    print(&quot;拖拽滚动条向下移动...&quot;)</span><br><span class="line">    auto.DragDrop(x, y, x, vScrollBarRect.bottom, waitTime=1)</span><br><span class="line">    print(&quot;关闭设备管理器&quot;)</span><br><span class="line">    mmcWindow.GetWindowPattern().Close()</span><br><span class="line">    input(&quot;已经运行完毕，回车结束&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    if auto.IsUserAnAdmin():</span><br><span class="line">        main()</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;RunScriptAsAdmin&#x27;, sys.executable, sys.argv)</span><br><span class="line">        auto.RunScriptAsAdmin(sys.argv)</span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869</span><br></pre></td></tr></table></figure>

<p>运行过程：</p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_19.gif" alt="请添加图片描述"></p>
<h2 id="记事本文本输入与字体调整"><a href="#记事本文本输入与字体调整" class="headerlink" title="记事本文本输入与字体调整"></a>记事本文本输入与字体调整</h2><p>首先打开记事本窗口，调整大小激活并置顶：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import uiautomation as auto</span><br><span class="line">import subprocess</span><br><span class="line"># 设置全局搜索超时时间为1秒</span><br><span class="line">auto.uiautomation.SetGlobalSearchTimeout(1)</span><br><span class="line"></span><br><span class="line"># 查找notepad</span><br><span class="line">note = auto.WindowControl(</span><br><span class="line">    searchDepth=1, ClassName=&#x27;Notepad&#x27;, RegexName=&#x27;.* - 记事本&#x27;)</span><br><span class="line">if not auto.WaitForExist(note, 0.1):</span><br><span class="line">    subprocess.Popen(&#x27;notepad&#x27;)</span><br><span class="line">sw, sh = auto.GetScreenSize()</span><br><span class="line">note.MoveWindow(sw // 10, sh // 10, sw // 2, sh // 2)</span><br><span class="line">note.SetActive()</span><br><span class="line">note.SetTopmost()</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure>

<p>下面我们测试一下文本输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">text = &quot;&quot;&quot;Windows中GUI自动化的三种技术：Windows API, MSAA - Microsoft Active Accessibility, UIAutomation</span><br><span class="line">用脚本语言AutoIT实现自动化就是第一种技术Windows API, 查找窗口句柄实现的。</span><br><span class="line">用工具Spy++查看程序，如果Spy++能识别程序窗口中的控件就能用这种技术。</span><br><span class="line">python的UI自动化测试模块 pywinauto，也是用这种技术实现的(现在pywinauto也支持UIAutomation了)。 </span><br><span class="line">但Windows API实现的自动化不支持WPF程序、Windows 8中的Metro程序，因为它们的控件都是自绘出来的，没有句柄的概念。</span><br><span class="line">用UIAutomation实现的自动化支持微软提供的各种界面开发框架，如Win32, MFC, Windows Forms, WPF, Metro App, IE。</span><br><span class="line">Qt, Firefox, Chrome实现了UI Automation Provider，也支持UIAutomation.</span><br><span class="line"></span><br><span class="line">tip:</span><br><span class="line">Win10系统下应该使用64位Python运行本程序，32位进程无法正确获取一些控件的边界坐标。</span><br><span class="line">详见：https://github.com/microsoft/accessibility-insights-windows/issues/1122</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">edit = note.EditControl()</span><br><span class="line">edit.Click(waitTime=0)</span><br><span class="line">edit.GetValuePattern().SetValue(&#x27;你好&#x27;)</span><br><span class="line">edit.SendKeys(&#x27;&#123;Ctrl&#125;&#123;End&#125;&#123;Enter&#125;下面开始演示&#123;! 4&#125;&#123;ENTER&#125;&#x27;, 0.2, 0)</span><br><span class="line">edit.SendKeys(text)</span><br><span class="line">edit.SendKeys(&#x27;&#123;Enter 3&#125;0123456789&#123;Enter&#125;&#x27;, waitTime=0)</span><br><span class="line">edit.SendKeys(&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#123;ENTER&#125;&#x27;, waitTime=0)</span><br><span class="line">edit.SendKeys(&#x27;abcdefghijklmnopqrstuvwxyz&#123;ENTER&#125;&#x27;, waitTime=0)</span><br><span class="line">edit.SendKeys(&#x27;`~!@#$%^&amp;*()-_=+&#123;ENTER&#125;&#x27;, waitTime=0)</span><br><span class="line">edit.SendKeys(&#x27;[]&#123;&#123;&#125;&#123;&#125;&#125;\\|;:\&#x27;\&quot;,&lt;.&gt;/?&#123;ENTER&#125;&#x27;, waitTime=0)</span><br><span class="line">edit.SendKeys(&#x27;™®①②③④⑤⑥⑦⑧⑨⑩§№☆★○●◎◇◆□℃‰€■△▲※→←↑↓〓¤°＃＆＠＼＾＿―♂♀&#x27;)</span><br><span class="line">edit.SendKeys(&quot;&#123;ENTER&#125;&#123;CTRL&#125;a&quot;)</span><br><span class="line">note.CaptureToImage(&#x27;Notepad.png&#x27;)</span><br><span class="line">1234567891011121314151617181920212223</span><br></pre></td></tr></table></figure>

<p>其中SendKeys的参数为：control.SendKeys(text: str, interval: float = 0.01,waitTime: float = 0.5, charMode: bool = True)</p>
<p>interval参数决定了输入的间隔，修改这个参数为0.2减慢了输入的频率更像打字机的效果。</p>
<p>最终产生的截图为：</p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_20.png?x-oss-process=style/watermark" alt="image-20211113143004093"></p>
<p>下面我们修改一下字体相关信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查找菜单</span><br><span class="line">note.MenuItemControl(Name=&#x27;格式(O)&#x27;).Click()</span><br><span class="line">note.MenuItemControl(Name=&#x27;字体(F)...&#x27;).Click()</span><br><span class="line">windowFont = note.WindowControl(Name=&#x27;字体&#x27;)</span><br><span class="line">font_data = &#123;&quot;字体(F):&quot;: &quot;微软雅黑&quot;, &quot;字形(Y):&quot;: &quot;常规&quot;, &quot;大小(S):&quot;: &quot;小四&quot;&#125;</span><br><span class="line">for k, v in font_data.items():</span><br><span class="line">    listItem = windowFont.ListControl(</span><br><span class="line">        searchDepth=2, AutomationId=&#x27;1000&#x27;, Name=k).ListItemControl(Name=v)</span><br><span class="line">    if listItem.Exists(1):</span><br><span class="line">        listItem.GetScrollItemPattern().ScrollIntoView()</span><br><span class="line">        listItem.Click()</span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure>

<p>其中ScrollIntoView()方法滚动目标到可见区域。</p>
<p>可以通过以下方面打印字体列表中的所有可选字体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">font_ListControl = windowFont.ListControl(</span><br><span class="line">    searchDepth=2, AutomationId=&#x27;1000&#x27;, Name=&quot;字体(F):&quot;)</span><br><span class="line">for item, depth in auto.WalkControl(font_ListControl, includeTop=True, maxDepth=2):</span><br><span class="line">    if depth != 1 or item.ControlType != auto.ControlType.ListItemControl:</span><br><span class="line">        continue</span><br><span class="line">    print(item.Name)</span><br><span class="line">12345</span><br><span class="line">Agency FB</span><br><span class="line">Algerian</span><br><span class="line">Arial</span><br><span class="line">...</span><br><span class="line">微软雅黑</span><br><span class="line">新宋体</span><br><span class="line">幼圆</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<p>对于需要展开的项目则需要先展开下拉列表，例如打印所有的脚本项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">windowFont.SetActive()</span><br><span class="line">combo = windowFont.ComboBoxControl(AutomationId=&#x27;1140&#x27;)</span><br><span class="line">pattern = combo.GetExpandCollapsePattern()</span><br><span class="line">if pattern.ExpandCollapseState == auto.ExpandCollapseState.Collapsed:</span><br><span class="line">    pattern.Expand(waitTime=0)</span><br><span class="line">for item, depth in auto.WalkControl(combo, includeTop=True, maxDepth=2):</span><br><span class="line">    if depth != 2 or item.ControlType != auto.ControlType.ListItemControl:</span><br><span class="line">        continue</span><br><span class="line">    print(item.Name)</span><br><span class="line">12345678</span><br><span class="line">中文 GB2312</span><br><span class="line">西欧语言</span><br><span class="line">希腊语</span><br><span class="line">土耳其语</span><br><span class="line">中欧字符</span><br><span class="line">西里尔文</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>我们选择中文类型的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">combo.Select(&#x27;中文 GB2312&#x27;)</span><br></pre></td></tr></table></figure>

<p>最后点击确定按钮：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windowFont.ButtonControl(Name=&#x27;确定&#x27;).Click()</span><br></pre></td></tr></table></figure>

<p><strong>完整代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">import uiautomation as auto</span><br><span class="line">import subprocess</span><br><span class="line"># 设置全局搜索超时时间为1秒</span><br><span class="line">auto.uiautomation.SetGlobalSearchTimeout(1)</span><br><span class="line"></span><br><span class="line"># 查找notepad</span><br><span class="line">note = auto.WindowControl(</span><br><span class="line">    searchDepth=1, ClassName=&#x27;Notepad&#x27;, RegexName=&#x27;.* - 记事本&#x27;)</span><br><span class="line">if not auto.WaitForExist(note, 0.1):</span><br><span class="line">    subprocess.Popen(&#x27;notepad&#x27;)</span><br><span class="line">sw, sh = auto.GetScreenSize()</span><br><span class="line">note.MoveWindow(sw // 10, sh // 10, sw // 2, sh // 2)</span><br><span class="line">note.SetActive()</span><br><span class="line">note.SetTopmost()</span><br><span class="line">text = &quot;&quot;&quot;Windows中GUI自动化的三种技术：Windows API, MSAA - Microsoft Active Accessibility, UIAutomation</span><br><span class="line">用脚本语言AutoIT实现自动化就是第一种技术Windows API, 查找窗口句柄实现的。</span><br><span class="line">用工具Spy++查看程序，如果Spy++能识别程序窗口中的控件就能用这种技术。</span><br><span class="line">python的UI自动化测试模块 pywinauto，也是用这种技术实现的(现在pywinauto也支持UIAutomation了)。 </span><br><span class="line">但Windows API实现的自动化不支持WPF程序、Windows 8中的Metro程序，因为它们的控件都是自绘出来的，没有句柄的概念。</span><br><span class="line">用UIAutomation实现的自动化支持微软提供的各种界面开发框架，如Win32, MFC, Windows Forms, WPF, Metro App, IE。</span><br><span class="line">Qt, Firefox, Chrome实现了UI Automation Provider，也支持UIAutomation.</span><br><span class="line"></span><br><span class="line">tip:</span><br><span class="line">Win10系统下应该使用64位Python运行本程序，32位进程无法正确获取一些控件的边界坐标。</span><br><span class="line">详见：https://github.com/microsoft/accessibility-insights-windows/issues/1122</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">edit = note.EditControl()</span><br><span class="line">edit.Click(waitTime=0)</span><br><span class="line">edit.GetValuePattern().SetValue(&#x27;你好&#x27;)</span><br><span class="line">edit.SendKeys(&#x27;&#123;Ctrl&#125;&#123;End&#125;&#123;Enter&#125;下面开始演示&#123;! 4&#125;&#123;ENTER&#125;&#x27;, 0.2, 0)</span><br><span class="line">edit.SendKeys(text)</span><br><span class="line">edit.SendKeys(&#x27;&#123;Enter 3&#125;0123456789&#123;Enter&#125;&#x27;, waitTime=0)</span><br><span class="line">edit.SendKeys(&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#123;ENTER&#125;&#x27;, waitTime=0)</span><br><span class="line">edit.SendKeys(&#x27;abcdefghijklmnopqrstuvwxyz&#123;ENTER&#125;&#x27;, waitTime=0)</span><br><span class="line">edit.SendKeys(&#x27;`~!@#$%^&amp;*()-_=+&#123;ENTER&#125;&#x27;, waitTime=0)</span><br><span class="line">edit.SendKeys(&#x27;[]&#123;&#123;&#125;&#123;&#125;&#125;\\|;:\&#x27;\&quot;,&lt;.&gt;/?&#123;ENTER&#125;&#x27;, waitTime=0)</span><br><span class="line">edit.SendKeys(&#x27;™®①②③④⑤⑥⑦⑧⑨⑩§№☆★○●◎◇◆□℃‰€■△▲※→←↑↓〓¤°＃＆＠＼＾＿―♂♀&#x27;)</span><br><span class="line">edit.SendKeys(&quot;&#123;ENTER&#125;&#123;CTRL&#125;a&quot;)</span><br><span class="line">note.CaptureToImage(&#x27;Notepad.png&#x27;)</span><br><span class="line"># 查找菜单</span><br><span class="line">note.MenuItemControl(Name=&#x27;格式(O)&#x27;).Click()</span><br><span class="line">note.MenuItemControl(Name=&#x27;字体(F)...&#x27;).Click()</span><br><span class="line">windowFont = note.WindowControl(Name=&#x27;字体&#x27;)</span><br><span class="line">font_data = &#123;&quot;字体(F):&quot;: &quot;微软雅黑&quot;, &quot;字形(Y):&quot;: &quot;常规&quot;, &quot;大小(S):&quot;: &quot;小四&quot;&#125;</span><br><span class="line">for k, v in font_data.items():</span><br><span class="line">    listItem = windowFont.ListControl(</span><br><span class="line">        searchDepth=2, AutomationId=&#x27;1000&#x27;, Name=k).ListItemControl(Name=v)</span><br><span class="line">    if listItem.Exists(1):</span><br><span class="line">        listItem.GetScrollItemPattern().ScrollIntoView()</span><br><span class="line">        listItem.Click()</span><br><span class="line">windowFont.SetActive()</span><br><span class="line">combo = windowFont.ComboBoxControl(AutomationId=&#x27;1140&#x27;)</span><br><span class="line">combo.Select(&#x27;中文 GB2312&#x27;)</span><br><span class="line">windowFont.ButtonControl(Name=&#x27;确定&#x27;).Click()</span><br><span class="line">note.SetTopmost(False)</span><br><span class="line">subprocess.Popen(&#x27;Notepad.png&#x27;, shell=True)</span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_21.gif" alt="请添加图片描述"></p>
<h2 id="wireshark抓包数据读取"><a href="#wireshark抓包数据读取" class="headerlink" title="wireshark抓包数据读取"></a>wireshark抓包数据读取</h2><p>下面我们演示如何保存wireshark抓包到的数据。首先我们需要自行打开wireshark程序后进行抓包。抓包几秒钟后有了如下结果：</p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_22.png?x-oss-process=style/watermark" alt="image-20211113172346882"></p>
<p>下面我们的目标是保存这个表格的数据。</p>
<p>首先我们需要获取wireshark的窗口对象，经过inspect工具的检查，ClassName和AutomationId均为MainWindow：</p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_23.png?x-oss-process=style/watermark" alt="image-20211113170212787"></p>
<p>这个对象的Name属性与窗口标题一致会根据状态不断变化，所以不能作为一个查找项，正常情况在能够保证开的窗口很少的情况下，我们可以通过如下简单的代码获取到wireshark的窗口对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">win = auto.WindowControl(</span><br><span class="line">    searchDepth=1, ClassName=&#x27;MainWindow&#x27;, AutomationId=&#x27;MainWindow&#x27;)</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>但是ClassName值为MainWindow的窗口实在太多了，我们无法确认时就需要其他方法来查找窗口，否则可能找到的窗口并不是wireshark。</p>
<p>但是wireshark有个过滤选择器工具栏的AutomationId为”MainWindow.displayFilterToolBar”：</p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_24.png?x-oss-process=style/watermark" alt="image-20211113171242405"></p>
<p>我们可以以此为唯一标识找出wireshark窗口对象。</p>
<p>思路：从桌面根对象下面开始遍历每个窗口对象，判断它是否存在AutomationId为”MainWindow.displayFilterToolBar”的工具栏，找到即可返回，具体编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import uiautomation as auto</span><br><span class="line">import time</span><br><span class="line"># 设置全局搜索超时时间为1秒</span><br><span class="line">auto.uiautomation.SetGlobalSearchTimeout(1)</span><br><span class="line"></span><br><span class="line">def find_wiresharkWindow():</span><br><span class="line">    for win in auto.GetRootControl().GetChildren():</span><br><span class="line">        if win.ClassName != &#x27;MainWindow&#x27; or win.AutomationId != &#x27;MainWindow&#x27;:</span><br><span class="line">            continue</span><br><span class="line">        if win.ToolBarControl(AutomationId=&#x27;MainWindow.displayFilterToolBar&#x27;).Exists(0, 0):</span><br><span class="line">            return win</span><br><span class="line">123456789</span><br></pre></td></tr></table></figure>

<p>然后我们在获取到窗口后，调整一下窗口位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wiresharkWindow = find_wiresharkWindow()</span><br><span class="line">sw, sh = auto.GetScreenSize()</span><br><span class="line">wiresharkWindow.MoveWindow(10, 10, sw // 2, sh * 3 // 5)</span><br><span class="line">wiresharkWindow.SetActive(waitTime=0.1)</span><br><span class="line">wiresharkWindow.SetTopmost()</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>然后可以开始遍历树控件获取数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;按下F12可中止程序遍历&quot;)</span><br><span class="line">tree = wiresharkWindow.TreeControl(</span><br><span class="line">    searchDepth=4, ClassName=&#x27;PacketList&#x27;, Name=&#x27;Packet list&#x27;)</span><br><span class="line">rect = tree.BoundingRectangle</span><br><span class="line">tree.Click(y=50, waitTime=0.1)</span><br><span class="line">auto.SendKeys(&#x27;&#123;Home&#125;&#x27;, waitTime=0.1)</span><br><span class="line">treeItemCount = 0</span><br><span class="line">columnCount = 0</span><br><span class="line">for item, depth in auto.WalkControl(tree):</span><br><span class="line">    if isinstance(item, auto.HeaderControl):</span><br><span class="line">        print(item.Name, end=&quot; &quot;)</span><br><span class="line">        columnCount += 1</span><br><span class="line">    elif isinstance(item, auto.TreeItemControl):</span><br><span class="line">        if treeItemCount % columnCount == 0:</span><br><span class="line">            print()</span><br><span class="line">        treeItemCount += 1</span><br><span class="line">        print(item.Name, end=&quot; &quot;)</span><br><span class="line">        if item.BoundingRectangle.bottom &gt;= rect.bottom:</span><br><span class="line">            auto.SendKeys(&#x27;&#123;PageDown&#125;&#x27;, waitTime=0.1)</span><br><span class="line">    if auto.IsKeyPressed(auto.Keys.VK_F12):</span><br><span class="line">        print(&quot;F12已被按下，停止采集&quot;)</span><br><span class="line">        break</span><br><span class="line">123456789101112131415161718192021</span><br></pre></td></tr></table></figure>

<p>为了避免程序持续无休止的运行，增加快捷键判断，循环中发现某个快捷键被按下则退出循环。可以看到打印结果很完美：</p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_25.png?x-oss-process=style/watermark" alt="image-20211113173852600"></p>
<p>下面我们重新组织一下代码，使结果最终能保存为pandas的datafream对象，<strong>完整代码如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import uiautomation as auto</span><br><span class="line"></span><br><span class="line"># 设置全局搜索超时时间为1秒</span><br><span class="line">auto.uiautomation.SetGlobalSearchTimeout(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def find_wiresharkWindow():</span><br><span class="line">    for win in auto.GetRootControl().GetChildren():</span><br><span class="line">        if win.ClassName != &#x27;MainWindow&#x27; or win.AutomationId != &#x27;MainWindow&#x27;:</span><br><span class="line">            continue</span><br><span class="line">        if win.ToolBarControl(AutomationId=&#x27;MainWindow.displayFilterToolBar&#x27;).Exists(0, 0):</span><br><span class="line">            return win</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wiresharkWindow = find_wiresharkWindow()</span><br><span class="line">sw, sh = auto.GetScreenSize()</span><br><span class="line">wiresharkWindow.MoveWindow(10, 10, sw // 2, sh * 3 // 5)</span><br><span class="line">wiresharkWindow.SetActive(waitTime=0.1)</span><br><span class="line">wiresharkWindow.SetTopmost()</span><br><span class="line"></span><br><span class="line">print(&quot;按下F12可中止程序遍历&quot;)</span><br><span class="line">tree = wiresharkWindow.TreeControl(</span><br><span class="line">    searchDepth=4, ClassName=&#x27;PacketList&#x27;, Name=&#x27;Packet list&#x27;)</span><br><span class="line">rect = tree.BoundingRectangle</span><br><span class="line">tree.Click(y=50, waitTime=0.1)</span><br><span class="line">auto.SendKeys(&#x27;&#123;Home&#125;&#x27;, waitTime=0.1)</span><br><span class="line">treeItemCount = 0</span><br><span class="line">columnCount = 0</span><br><span class="line">header = []</span><br><span class="line">data, row = [], []</span><br><span class="line">for item, depth in auto.WalkControl(tree):</span><br><span class="line">    if isinstance(item, auto.HeaderControl):</span><br><span class="line">        header.append(item.Name)</span><br><span class="line">        columnCount += 1</span><br><span class="line">    elif isinstance(item, auto.TreeItemControl):</span><br><span class="line">        if row and treeItemCount % columnCount == 0:</span><br><span class="line">            data.append(row)</span><br><span class="line">            row = []</span><br><span class="line">        treeItemCount += 1</span><br><span class="line">        row.append(item.Name)</span><br><span class="line">        if item.BoundingRectangle.bottom &gt;= rect.bottom:</span><br><span class="line">            auto.SendKeys(&#x27;&#123;PageDown&#125;&#x27;, waitTime=0.1)</span><br><span class="line">    if auto.IsKeyPressed(auto.Keys.VK_F12):</span><br><span class="line">        print(&quot;F12已被按下，停止采集&quot;)</span><br><span class="line">        break</span><br><span class="line">wiresharkWindow.SetTopmost(False)</span><br><span class="line">if row:</span><br><span class="line">    data.append(row)</span><br><span class="line">df = pd.DataFrame(data, columns=header)</span><br><span class="line">df</span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738394041424344</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_26.png?x-oss-process=style/watermark" alt="image-20211113180144045"></p>
<h2 id="PDF目录折叠展开提取器"><a href="#PDF目录折叠展开提取器" class="headerlink" title="PDF目录折叠展开提取器"></a>PDF目录折叠展开提取器</h2><p>本例计划开发一个针对树形控件的折叠展开工具，计划开发三个热键功能：</p>
<ul>
<li></li>
<li><p>递归展开某树形控件</p>
</li>
<li></li>
<li><p>递归折叠某树形控件</p>
</li>
<li></li>
<li><p>递归提取整棵树的文本</p>
</li>
<li></li>
</ul>
<p>当我们按某个快捷键时，则会自动定位当前鼠标下的控件，是树形控件时就会进行对应的操作。针对递归提取整棵树的文本，鼠标放到一个树形控件的任意位置，都会自动定位当前树的祖先控件。</p>
<p>下面针对这三个功能注册热键为Ctrl+1，Ctrl+2，Ctrl+3。最终完整代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">import uiautomation as auto</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def ExpandTreeItem(stopEvent):</span><br><span class="line">    with auto.UIAutomationInitializerInThread():</span><br><span class="line">        tree = auto.ControlFromCursor()</span><br><span class="line">        if tree.ControlType not in [auto.ControlType.TreeControl, auto.ControlType.TreeItemControl]:</span><br><span class="line">            return</span><br><span class="line">        for item, depth in auto.WalkControl(tree, includeTop=True):</span><br><span class="line">            if not isinstance(item, auto.TreeItemControl):</span><br><span class="line">                continue</span><br><span class="line">            ecpt = item.GetExpandCollapsePattern()</span><br><span class="line">            if ecpt and ecpt.ExpandCollapseState == auto.ExpandCollapseState.Collapsed:</span><br><span class="line">                sipt = item.GetScrollItemPattern()</span><br><span class="line">                if sipt:</span><br><span class="line">                    sipt.ScrollIntoView(waitTime=0.01)</span><br><span class="line">                ecpt.Expand(waitTime=0.01)</span><br><span class="line">        sipt = tree.GetScrollItemPattern()</span><br><span class="line">        if sipt:</span><br><span class="line">            sipt.ScrollIntoView(waitTime=0.01)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def copy_pdf_catalog(stopEvent):</span><br><span class="line">    result = []</span><br><span class="line">    with auto.UIAutomationInitializerInThread():</span><br><span class="line">        tree = auto.ControlFromCursor()</span><br><span class="line">        if tree.ControlType not in [auto.ControlType.TreeControl, auto.ControlType.TreeItemControl]:</span><br><span class="line">            return</span><br><span class="line">        tree = tree.GetAncestorControl(lambda c, d: isinstance(c, auto.TreeControl))</span><br><span class="line">        for item, depth in auto.WalkControl(tree, includeTop=True):</span><br><span class="line">            if not isinstance(item, auto.TreeItemControl):</span><br><span class="line">                continue</span><br><span class="line">            name = item.Name</span><br><span class="line">            if name:</span><br><span class="line">                print(&quot;\t&quot; * (depth - 1) + name)</span><br><span class="line">                result.append(&quot;\t&quot; * (depth - 1) + name)</span><br><span class="line">            ecpt = item.GetExpandCollapsePattern()</span><br><span class="line">            if ecpt and ecpt.ExpandCollapseState == auto.ExpandCollapseState.Collapsed:</span><br><span class="line">                sipt = item.GetScrollItemPattern()</span><br><span class="line">                if sipt:</span><br><span class="line">                    sipt.ScrollIntoView(waitTime=0.01)</span><br><span class="line">                ecpt.Expand(waitTime=0.01)</span><br><span class="line">    text = &quot;\n&quot;.join(result)</span><br><span class="line">    auto.SetClipboardText(text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def CollapseTreeItem_recursion(treeItem: auto.TreeItemControl):</span><br><span class="line">    if not isinstance(treeItem, auto.TreeItemControl):</span><br><span class="line">        return</span><br><span class="line">    children = treeItem.GetChildren()</span><br><span class="line">    if not children:</span><br><span class="line">        return</span><br><span class="line">    for it in children:</span><br><span class="line">        CollapseTreeItem_recursion(it)</span><br><span class="line">    ecpt = treeItem.GetExpandCollapsePattern()</span><br><span class="line">    if ecpt and ecpt.ExpandCollapseState == auto.ExpandCollapseState.Expanded:</span><br><span class="line">        ecpt.Collapse(waitTime=0.05)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def collapseTreeItem(stopEvent):</span><br><span class="line">    with auto.UIAutomationInitializerInThread():</span><br><span class="line">        treeItem = auto.ControlFromCursor()</span><br><span class="line">        CollapseTreeItem_recursion(treeItem)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    auto.RunByHotKey(&#123;</span><br><span class="line">        (auto.ModifierKey.Control, auto.Keys.VK_1): collapseTreeItem,</span><br><span class="line">        (auto.ModifierKey.Control, auto.Keys.VK_2): ExpandTreeItem,</span><br><span class="line">        (auto.ModifierKey.Control, auto.Keys.VK_3): copy_pdf_catalog,</span><br><span class="line">    &#125;, waitHotKeyReleased=False)</span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960</span><br></pre></td></tr></table></figure>

<p>经测试对极速PDF的目录完全有效，我们可以用来递归折叠或展开PDF的目录，或者直接从UI提取目录的内容。</p>
<p>运行后程序显示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Register hotkey (&#x27;Control&#x27;, &#x27;VK_1&#x27;) successfully</span><br><span class="line">Register hotkey (&#x27;Control&#x27;, &#x27;VK_2&#x27;) successfully</span><br><span class="line">Register hotkey (&#x27;Control&#x27;, &#x27;VK_3&#x27;) successfully</span><br><span class="line">Register exit hotkey (&#x27;Control&#x27;, &#x27;VK_D&#x27;) successfully</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>先按下Ctrl+1测试一下折叠功能（录屏软件挡住时无法获取到鼠标下的控件，所以用手机录）：</p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_27.gif" alt="请添加图片描述"></p>
<p>按下Ctrl+2则非常顺利的进行了相应的反向操作，大家可以自己感受一下。</p>
<p>按下Ctrl+3，执行完毕后，我将剪切板中的内容粘贴到记事本：</p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/2021/2021-11/2021-11-19/d6acb36960f64c9b98babcf538797296_28.png?x-oss-process=style/watermark" alt="image-20211118004639754"></p>
<p>可以看到已经完美提取出PDF的目录，该复制到剪切板中的目录还可以直接粘贴到思维导图中。</p>
<blockquote>
<p>原文: <a target="_blank" rel="noopener" href="https://blog.csdn.net/as604049322/article/details/121391639">https://blog.csdn.net/as604049322/article/details/121391639</a></p>
</blockquote>
<p>发表评论</p>
<p>暂无评论</p>
<p><a target="_blank" rel="noopener" href="https://www.daima.net/tjk"><img src="https://daimanet.oss-cn-beijing.aliyuncs.com//2022/2022-01/2022-01-16/daimanet.jpg?x-oss-process=style/HEADER" alt="img">tjk</a></p>
<p>关注</p>
<p>170</p>
<p>0</p>
<p>0</p>
<p>浏览量</p>
<p>粉丝</p>
<p>关注</p>
<p><img src="https://daimanet.oss-cn-beijing.aliyuncs.com/index/logo.jpg?x-oss-process=style/HEADER" alt="img"></p>
<p>友情链接: <a target="_blank" rel="noopener" href="https://www.daima.net/">代码网</a> <a target="_blank" rel="noopener" href="https://suowo.cn/">短链接</a> <a target="_blank" rel="noopener" href="http://www.fzvps.com/">飞纵云</a></p>
<p><a target="_blank" rel="noopener" href="https://www.daima.net/">Copyright©代码网 2003 - 2020</a> <a target="_blank" rel="noopener" href="https://www.daima.net/help?type=1">免责声明</a> <a target="_blank" rel="noopener" href="https://www.daima.net/help?type=2">侵权联系</a> <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">陕ICP备2021014434号-1</a></p>
<p>set 限制解除 </p>
<p><img src="chrome-extension:/golkpggaiebgepbccjaoifgeeemiacoo/images/logo_64.png" alt="img"></p>

            <p style="text-align: center;">希望这篇文章能给你带来知识和乐趣，喜欢博主的文章可以加博主好友哦<img class="owoemoji" src="/OwO/img/脸红.png"></p>
            <p style="text-align: center;">有好的文章也可以向博主投稿哦<img class="owoemoji" src="/OwO/img/期待.png"></p>
        </div>
        <div style="text-align:center" class="social-share" data-disabled="facebook, twitter, google"></div>
        <p style="text-align: center;">您的喜欢是作者写作最大的动力<img class="owoemoji" src="/OwO/img/爱心.png"></p>
        

        <div class="post-tool">
            <a class="btn-weixin-tip" href="javascript:void(0);">
                <i class="fa fa-mobile" aria-hidden="true"></i> 打赏支持
            </a>
        </div>

        <p style="text-align: center;"><img class="owoemoji" src="/OwO/img/太开心.png">QQ群和公众号
        <p style="text-align: center;"><img height="200px" src="https://cdn.jsdelivr.net/gh/MuyanGit/ImageHosting/sina/006bYVyvly1g22ie1sr2jj306m06ywef.jpg"><img src="https://cdn.jsdelivr.net/gh/MuyanGit/ImageHosting/sina/006bYVyvly1g1ksxfx94qj309k09k3yg.jpg"></p>
        
        
        <div class="post-tags">标签：
            
        </div>
        
    </article>
    <div class="post-nav">
        
        
        <div class="post-nav-next post-nav-item">
            <a href="/2021/11/18/cl4s605do0042awbhfhrh8u9q/" >英文文本分词之工具NLTK<i class="fa fa-chevron-right"></i></a>
        </div>
        
    </div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/honjun/hexo-helper-tocbot/css/tocbot.css"><style>
    .js-toc {
        width: 200px;
        height: auto;
        z-index: 98;
        background-color: rgba(255,255,255,0);
        transform: translateX(0);
        right: calc((100% - 950px - 250px) / 2);
        top: 60px;
        position: fixed;
        padding-top: 10px;
        padding-bottom: 10px;
    }
  </style><script src="https://cdn.jsdelivr.net/gh/honjun/hexo-helper-tocbot/js/tocbot.js"></script><div class="js-toc"></div><script type="text/javascript">
    tocbot.init({"contentSelector":".post-content","scrollSmooth":true,"headingSelector":"h1, h2, h3, h4, h5","headingsOffset":45,"scrollSmoothOffset":-45,"tocSelector":".js-toc","ignoreSelector":".js-toc-ignore","linkClass":"toc-link","extraLinkClasses":"","activeLinkClass":"is-active-link","listClass":"toc-list","extraListClasses":"","isCollapsedClass":"is-collapsed","collapsibleClass":"is-collapsible","listItemClass":"toc-list-item","activeListItemClass":"is-active-li","collapseDepth":0,"scrollSmoothDuration":420,"throttleTimeout":50,"positionFixedSelector":null,"positionFixedClass":"is-position-fixed","fixedSidebarOffset":"auto","includeHtml":false,"onClick":false,"orderedList":true,"scrollContainer":null})
  </script>
    <!-- 
<aside id="article-toc" role="navigation" class="fixed">
    <div id="article-toc-inner">
        <strong class="sidebar-title">
        目录</strong>
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95"><span class="toc-text">文章目录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%94%E8%AE%B0"><span class="toc-text">笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%EF%BC%9A%E6%96%9C%E6%9D%A0%E6%95%B0%E9%87%8F-1"><span class="toc-text">深度：斜杠数量+1</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D"><span class="toc-text">功能介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">基本原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A7%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%85%A5%E9%97%A8%EF%BC%9A%E8%AE%B0%E4%BA%8B%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">控件控制入门：记事本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E4%BB%B6%E5%88%86%E6%9E%90%E4%B8%8E%E5%8F%AF%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-text">控件分析与可用参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E4%BB%B6%E5%BB%B6%E8%BF%9F%E6%90%9C%E7%B4%A2%E6%9C%BA%E5%88%B6"><span class="toc-text">控件延迟搜索机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%BF%9E%E7%BB%AD%E6%89%93%E5%BC%80%E4%B8%89%E4%B8%AA%E8%AE%B0%E4%BA%8B%E6%9C%AC%E5%B9%B6%E5%85%B3%E9%97%AD"><span class="toc-text">示例：连续打开三个记事本并关闭</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UIAutomation%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8A%9F%E8%83%BD"><span class="toc-text">UIAutomation的常见功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-text">基本方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%AA%97%E5%8F%A3%E5%AF%B9%E8%B1%A1"><span class="toc-text">获取窗口对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E4%BB%B6%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95"><span class="toc-text">控件查找方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%B1%9E%E6%80%A7%E8%B0%83%E6%95%B4"><span class="toc-text">窗口属性调整</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WalkTree%E9%81%8D%E5%8E%86%E5%AD%90%E6%8E%A7%E4%BB%B6"><span class="toc-text">WalkTree遍历子控件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bitmap%E4%BD%8D%E5%9B%BE%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">Bitmap位图对象的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E5%A4%9A%E4%B8%AA%E6%98%BE%E7%A4%BA%E5%99%A8%E5%88%86%E5%88%AB%E6%88%AA%E5%B1%8F"><span class="toc-text">对多个显示器分别截屏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%AA%E5%88%87%E6%9D%BF%E6%93%8D%E4%BD%9C"><span class="toc-text">剪切板操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%B8%A6%E7%9A%84Logger%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%E7%B1%BB"><span class="toc-text">自带的Logger日志输出类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E7%83%AD%E9%94%AE%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">全局热键与多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%91%98%E6%8F%90%E6%9D%83"><span class="toc-text">管理员提权</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0UI%E8%87%AA%E5%8A%A8%E5%8C%96"><span class="toc-text">通过实例学习UI自动化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6win10%E8%AE%A1%E7%AE%97%E5%99%A8%E8%87%AA%E5%8A%A8%E8%AE%A1%E7%AE%97"><span class="toc-text">控制win10计算器自动计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E7%9A%84%E6%8B%96%E6%8B%BD%E4%B8%8E%E7%BC%A9%E6%94%BE"><span class="toc-text">窗口的拖拽与缩放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%91%98%E6%8F%90%E6%9D%83%E6%93%8D%E4%BD%9C%E5%B9%B6%E8%AF%BB%E5%8F%96%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%99%A8%E6%A0%8F%E7%9B%AE%E6%95%B0%E6%8D%AE"><span class="toc-text">管理员提权操作并读取设备管理器栏目数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E4%BA%8B%E6%9C%AC%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E4%B8%8E%E5%AD%97%E4%BD%93%E8%B0%83%E6%95%B4"><span class="toc-text">记事本文本输入与字体调整</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wireshark%E6%8A%93%E5%8C%85%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96"><span class="toc-text">wireshark抓包数据读取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PDF%E7%9B%AE%E5%BD%95%E6%8A%98%E5%8F%A0%E5%B1%95%E5%BC%80%E6%8F%90%E5%8F%96%E5%99%A8"><span class="toc-text">PDF目录折叠展开提取器</span></a>
    </div>
</aside>
 -->
     








<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<div id="vcomments"></div>
<!-- <span id="/2022/06/08/cl4s605cf001sawbhdef2fhpz/" class="leancloud-visitors" data-flag-title="文章阅读量统计">
    <span class="post-meta-item-text">阅读量 </span>
    <span class="leancloud-visitors-count">1000000</span>
</span> -->
<script>
  new Valine({
    el: '#vcomments',
    appId: "GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz",
    appKey: "mgOpfzbkHYqU92CV4IDlAUHQ",
    // visitor: true
  })
</script>




    
    
    
        <div class="adsense_post_left">
            
    <ins class="adsbygoogle"
         style="display:inline-block;width:160px;height:600px"
         data-ad-client="ca-pub-5634033670687375"
         data-ad-slot="9797686907"></ins>

<script>
    (adsbygoogle = window.adsbygoogle || []).push({});
</script>

        </div>
        <div class="adsense_post_right">
            
    <ins class="adsbygoogle"
         style="display:inline-block;width:160px;height:600px"
         data-ad-client="ca-pub-5634033670687375"
         data-ad-slot="7335051380"></ins>

<script>
    (adsbygoogle = window.adsbygoogle || []).push({});
</script>

        </div>
        
    <ins class="adsbygoogle"
         style="display:block"
         data-ad-client="ca-pub-5634033670687375"
         data-ad-slot="8296902977"
         data-ad-format="auto"
         data-full-width-responsive="true"></ins>

<script>
    (adsbygoogle = window.adsbygoogle || []).push({});
</script>

    


</div>
<!-- 不蒜子 网页计数器 -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        </div><!-- end #main-->
    </div><!-- end #body -->
    <footer class="footer">
    <div class="footer-inner">
        <!-- <a target="_blank" href="//shang.qq.com/wpa/qunwpa?idkey=0e48d2d6785c4b110daa7e450102de5ebe028e86bde31a428399911eb53bd450"><img border="0" src="//pub.idqqimg.com/wpa/images/group.png" alt="简书散人交流群" title="简书散人交流群"></a> -->
        <p id="hitokoto">:D 获取中...</p>
        <script>
          var xhr = new XMLHttpRequest();
          xhr.open('get', 'https://v1.hitokoto.cn');
          xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
              var data = JSON.parse(xhr.responseText);
              var hitokoto = document.getElementById('hitokoto');
              hitokoto.innerText = data.hitokoto + '  ——' + data.from;
            }
          }
          xhr.send();
        </script>
        <p>
            <a href="/about/MuyanGit.html"  title="关于作者">关于作者</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/help" title="关于" >关于</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/archives" title="归档">归档</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp

            <!-- 自定义链接 -->
            <a href="/links" title="友情链接">友情链接</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
        </p>
        <p>
            本站点采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>，已建立<a href="/timeline" id="siteBuildingTime"></a>天<br/>
            ©2017 基于<a href="http://hexo.io" target="_blank">Hexo</a>搭建
            ，主题&nbsp<a href="https://github.com/tangkunyin/hexo-theme-jsimple" target="_blank">JSimple</a>
            ，Hosted by <a href="https://github.com/" target="_blank">Github Pages</a>，Hosted by <a href="https://pages.coding.me" target="_blank">Coding Pages</a>
        </p>
        <p>从这里可以访问到我</p>
        <p>
          <!-- <a target="_blank" rel="noopener" href="https://shop206822225.taobao.com/index.htm"><img style="margin:5px;width: 100px; height: 100px;" src="https://cdn.jsdelivr.net/gh/MuyanGit/ImageHosting/sina/006bYVyvly1fwhbrhm111j30ia0iak0l.jpg" alt=""></a> -->
          <!-- <a href="javascript:"><img style="margin:5px;width: 100px; height: 100px;" src="https://cdn.jsdelivr.net/gh/MuyanGit/ImageHosting/sina/006bYVyvly1g1ksxfx94qj309k09k3yg.jpg" alt=""></a> -->
          <a target="_blank" rel="noopener" href="https://author.baidu.com/home/1594654793276567"><img style="margin:5px;width: 100px; height: 100px;" src="https://cdn.jsdelivr.net/gh/MuyanGit/ImageHosting/sina/006bYVyvgy1ftpw8983bjj308c08c77h.jpg" alt=""></a>
          <a target="_blank" rel="noopener" href="https://www.jianshu.com/u/e8537ffe74d6"><img style="margin:5px;width: 100px; height: 100px;" src="https://cdn.jsdelivr.net/gh/MuyanGit/ImageHosting/sina/006bYVyvgy1ftpw8a5u1lj308c08ctas.jpg" alt=""></a>
          <a target="_blank" rel="noopener" href="https://www.toutiao.com/c/user/71618825563/#mid=1595095174687757"><img style="margin:5px;width: 100px; height: 100px;" src="https://cdn.jsdelivr.net/gh/MuyanGit/ImageHosting/sina/006bYVyvgy1ftpw8aqarej308c08cadu.jpg" alt=""></a>
          <a target="_blank" rel="noopener" href="https://www.hojun.cn"><img style="margin:5px;width: 100px; height: 100px;" src="https://cdn.jsdelivr.net/gh/MuyanGit/ImageHosting/sina/006bYVyvgy1ftpw89p4kaj308c08c40a.jpg" alt=""></a>
        </p>
        <p id="cnzz"></p>
    </div>
</footer>

<script src="/js/jquery.min.js"></script>


<script src="/js/lozad.js"></script>


<script src="/js/jquery.share.min.js"></script>


<script src="/js/CodeLineHeight.js"></script>


<script src="/js/activate-power-mode.js"></script>


<script src="/js/xiaomai.js"></script>


<script src="/js/zoom.min.js"></script>


<script src="/js/jquery.fancybox.min.js"></script>


<script src="/js/InsightSearch.js"></script>
<script src="/js/SimpleCore.js"></script>

<!-- 
<script src="/js/loading.js"></script>
 -->
<!-- 
<script src="/js/APlayer.js"></script>
 -->
<!-- 
<script src="/js/aplayerdemo.js"></script>
 -->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?15e55c3816abfbc912d5cb0d9000a2d4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
(function() {
  var arr = new Array();
  var $tags = $('.post-tags').children('a');
  $tags.each(function() {
    arr.push($(this).html())
  })
  $('.fancybox').fancybox({
    padding: 0,
    loop: false
  });
})();
</script>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else{
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
</div>
<div id="spig" class="spig">
    <div id="message"></div>
    <div id="xiaomai"></div>
</div>
<div class="fixed-xm">
    <img src="/images/xiaomai/xm.png">
    <audio src="/images/xiaomai/xm.mp3" id="xm_audio" preload="auto" style="display:none;"></audio>
</div>
<div class="fixed-btn">
    <a class="btn-gotop" href="javascript:"> <i class="fa fa-angle-up"></i></a>
</div>
<script>
    $(function () {
        SimpleCore.init({
            buildingTime: '04/24/2017',
            current: $('.post-tags').length > 0 ? 'post' : 'archive',
            customImg: 'https://cdn.jsdelivr.net/gh/MuyanGit/ImageHosting/sina/006bYVyvgy1ftpw8983bjj308c08c77h.jpg',
            tipImg: 'https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/donate/WeChanSQ.jpg',
        });
        const observer = lozad();
        observer.observe();

        
        //打字特效
        POWERMODE.colorful = true; // make power mode colorful
        POWERMODE.shake = false; // turn off shake
        document.body.addEventListener('input', POWERMODE);

        //为超链接加上target='_blank'属性  
        $('a[href^="http"]').each(function() {  
            $(this).attr('target', '_blank');  
        });

        // window.onblur = function (){ 
        //     document.title = '快回来学习~'; 
        // };
        // window.onfocus = function (){ 
        //     document.title = 'hojun-言念君子，温其如玉！'; 
        // }; 
    });
</script>
</body>
</html>